{"version":3,"file":"index.web.js","mappings":"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","sources":["webpack://react-native-onyx/web/webpack/universalModuleDefinition","webpack://react-native-onyx/web/./node_modules/@babel/runtime/helpers/arrayLikeToArray.js","webpack://react-native-onyx/web/./node_modules/@babel/runtime/helpers/arrayWithHoles.js","webpack://react-native-onyx/web/./node_modules/@babel/runtime/helpers/arrayWithoutHoles.js","webpack://react-native-onyx/web/./node_modules/@babel/runtime/helpers/assertThisInitialized.js","webpack://react-native-onyx/web/./node_modules/@babel/runtime/helpers/classCallCheck.js","webpack://react-native-onyx/web/./node_modules/@babel/runtime/helpers/createClass.js","webpack://react-native-onyx/web/./node_modules/@babel/runtime/helpers/defineProperty.js","webpack://react-native-onyx/web/./node_modules/@babel/runtime/helpers/extends.js","webpack://react-native-onyx/web/./node_modules/@babel/runtime/helpers/getPrototypeOf.js","webpack://react-native-onyx/web/./node_modules/@babel/runtime/helpers/inherits.js","webpack://react-native-onyx/web/./node_modules/@babel/runtime/helpers/interopRequireDefault.js","webpack://react-native-onyx/web/./node_modules/@babel/runtime/helpers/iterableToArray.js","webpack://react-native-onyx/web/./node_modules/@babel/runtime/helpers/iterableToArrayLimit.js","webpack://react-native-onyx/web/./node_modules/@babel/runtime/helpers/nonIterableRest.js","webpack://react-native-onyx/web/./node_modules/@babel/runtime/helpers/nonIterableSpread.js","webpack://react-native-onyx/web/./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js","webpack://react-native-onyx/web/./node_modules/@babel/runtime/helpers/setPrototypeOf.js","webpack://react-native-onyx/web/./node_modules/@babel/runtime/helpers/slicedToArray.js","webpack://react-native-onyx/web/./node_modules/@babel/runtime/helpers/toConsumableArray.js","webpack://react-native-onyx/web/./node_modules/@babel/runtime/helpers/typeof.js","webpack://react-native-onyx/web/./node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js","webpack://react-native-onyx/web/./lib/Logger.js","webpack://react-native-onyx/web/./lib/Onyx.js","webpack://react-native-onyx/web/./lib/OnyxCache.js","webpack://react-native-onyx/web/./lib/SyncQueue.js","webpack://react-native-onyx/web/./lib/createDeferredTask.js","webpack://react-native-onyx/web/./lib/metrics/index.web.js","webpack://react-native-onyx/web/./lib/storage/WebStorage.js","webpack://react-native-onyx/web/./lib/storage/index.web.js","webpack://react-native-onyx/web/./lib/storage/providers/LocalForage.js","webpack://react-native-onyx/web/./lib/withOnyx.js","webpack://react-native-onyx/web/./node_modules/prop-types/factoryWithThrowingShims.js","webpack://react-native-onyx/web/./node_modules/prop-types/index.js","webpack://react-native-onyx/web/./node_modules/prop-types/lib/ReactPropTypesSecret.js","webpack://react-native-onyx/web/external umd \"expensify-common/lib/str\"","webpack://react-native-onyx/web/external umd \"localforage\"","webpack://react-native-onyx/web/external umd \"lodash/merge\"","webpack://react-native-onyx/web/external umd \"react\"","webpack://react-native-onyx/web/external umd \"underscore\"","webpack://react-native-onyx/web/webpack/bootstrap","webpack://react-native-onyx/web/webpack/runtime/global","webpack://react-native-onyx/web/./index.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"underscore\"), require(\"expensify-common/lib/str\"), require(\"lodash/merge\"), require(\"localforage\"), require(\"react\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"underscore\", \"expensify-common/lib/str\", \"lodash/merge\", \"localforage\", \"react\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"react-native-onyx/web\"] = factory(require(\"underscore\"), require(\"expensify-common/lib/str\"), require(\"lodash/merge\"), require(\"localforage\"), require(\"react\"));\n\telse\n\t\troot[\"react-native-onyx/web\"] = factory(root[\"underscore\"], root[\"expensify-common/lib/str\"], root[\"lodash/merge\"], root[\"localforage\"], root[\"react\"]);\n})(self, (__WEBPACK_EXTERNAL_MODULE__952__, __WEBPACK_EXTERNAL_MODULE__97__, __WEBPACK_EXTERNAL_MODULE__179__, __WEBPACK_EXTERNAL_MODULE__349__, __WEBPACK_EXTERNAL_MODULE__156__) => {\nreturn ","function _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nmodule.exports = _arrayLikeToArray;","function _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nmodule.exports = _arrayWithHoles;","var arrayLikeToArray = require(\"./arrayLikeToArray\");\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return arrayLikeToArray(arr);\n}\n\nmodule.exports = _arrayWithoutHoles;","function _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nmodule.exports = _assertThisInitialized;","function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nmodule.exports = _classCallCheck;","function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nmodule.exports = _createClass;","function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nmodule.exports = _defineProperty;","function _extends() {\n  module.exports = _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nmodule.exports = _extends;","function _getPrototypeOf(o) {\n  module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nmodule.exports = _getPrototypeOf;","var setPrototypeOf = require(\"./setPrototypeOf\");\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) setPrototypeOf(subClass, superClass);\n}\n\nmodule.exports = _inherits;","function _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nmodule.exports = _interopRequireDefault;","function _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nmodule.exports = _iterableToArray;","function _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nmodule.exports = _iterableToArrayLimit;","function _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nmodule.exports = _nonIterableRest;","function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nmodule.exports = _nonIterableSpread;","var _typeof = require(\"@babel/runtime/helpers/typeof\");\n\nvar assertThisInitialized = require(\"./assertThisInitialized\");\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return assertThisInitialized(self);\n}\n\nmodule.exports = _possibleConstructorReturn;","function _setPrototypeOf(o, p) {\n  module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nmodule.exports = _setPrototypeOf;","var arrayWithHoles = require(\"./arrayWithHoles\");\n\nvar iterableToArrayLimit = require(\"./iterableToArrayLimit\");\n\nvar unsupportedIterableToArray = require(\"./unsupportedIterableToArray\");\n\nvar nonIterableRest = require(\"./nonIterableRest\");\n\nfunction _slicedToArray(arr, i) {\n  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();\n}\n\nmodule.exports = _slicedToArray;","var arrayWithoutHoles = require(\"./arrayWithoutHoles\");\n\nvar iterableToArray = require(\"./iterableToArray\");\n\nvar unsupportedIterableToArray = require(\"./unsupportedIterableToArray\");\n\nvar nonIterableSpread = require(\"./nonIterableSpread\");\n\nfunction _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();\n}\n\nmodule.exports = _toConsumableArray;","function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    module.exports = _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    module.exports = _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nmodule.exports = _typeof;","var arrayLikeToArray = require(\"./arrayLikeToArray\");\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}\n\nmodule.exports = _unsupportedIterableToArray;","// Logging callback\nlet logger = () => {};\n\n/**\n * Register the logging callback\n *\n * @param {Function} callback\n */\nfunction registerLogger(callback) {\n    logger = callback;\n}\n\n/**\n * Send an alert message to the logger\n *\n * @param {String} message\n */\nfunction logAlert(message) {\n    logger({message: `[Onyx] ${message}`, level: 'alert'});\n}\n\n/**\n * Send an info message to the logger\n *\n * @param {String} message\n */\nfunction logInfo(message) {\n    logger({message: `[Onyx] ${message}`, level: 'info'});\n}\n\nexport {\n    registerLogger,\n    logInfo,\n    logAlert,\n};\n","import _ from 'underscore';\nimport Str from 'expensify-common/lib/str';\nimport lodashMerge from 'lodash/merge';\nimport Storage from './storage';\n\nimport {registerLogger, logInfo, logAlert} from './Logger';\nimport cache from './OnyxCache';\nimport createDeferredTask from './createDeferredTask';\n\n// Keeps track of the last connectionID that was used so we can keep incrementing it\nlet lastConnectionID = 0;\n\n// Holds a mapping of all the react components that want their state subscribed to a store key\nconst callbackToStateMapping = {};\n\n// Stores all of the keys that Onyx can use. Must be defined in init().\nlet onyxKeys = {};\n\n// Holds a list of keys that have been directly subscribed to or recently modified from least to most recent\nlet recentlyAccessedKeys = [];\n\n// Holds a list of keys that are safe to remove when we reach max storage. If a key does not match with\n// whatever appears in this list it will NEVER be a candidate for eviction.\nlet evictionAllowList = [];\n\n// Holds a map of keys and connectionID arrays whose keys will never be automatically evicted as\n// long as we have at least one subscriber that returns false for the canEvict property.\nconst evictionBlocklist = {};\n\n// Optional user-provided key value states set when Onyx initializes or clears\nlet defaultKeyStates = {};\n\n// Connections can be made before `Onyx.init`. They would wait for this task before resolving\nconst deferredInitTask = createDeferredTask();\n\n/**\n * Get some data from the store\n *\n * @private\n * @param {string} key\n * @returns {Promise<*>}\n */\nfunction get(key) {\n    // When we already have the value in cache - resolve right away\n    if (cache.hasCacheForKey(key)) {\n        return Promise.resolve(cache.getValue(key));\n    }\n\n    const taskName = `get:${key}`;\n\n    // When a value retrieving task for this key is still running hook to it\n    if (cache.hasPendingTask(taskName)) {\n        return cache.getTaskPromise(taskName);\n    }\n\n    // Otherwise retrieve the value from storage and capture a promise to aid concurrent usages\n    const promise = Storage.getItem(key)\n        .then((val) => {\n            cache.set(key, val);\n            return val;\n        })\n        .catch(err => logInfo(`Unable to get item from persistent storage. Key: ${key} Error: ${err}`));\n\n    return cache.captureTask(taskName, promise);\n}\n\n/**\n * Returns current key names stored in persisted storage\n * @private\n * @returns {Promise<string[]>}\n */\nfunction getAllKeys() {\n    // When we've already read stored keys, resolve right away\n    const storedKeys = cache.getAllKeys();\n    if (storedKeys.length > 0) {\n        return Promise.resolve(storedKeys);\n    }\n\n    const taskName = 'getAllKeys';\n\n    // When a value retrieving task for all keys is still running hook to it\n    if (cache.hasPendingTask(taskName)) {\n        return cache.getTaskPromise(taskName);\n    }\n\n    // Otherwise retrieve the keys from storage and capture a promise to aid concurrent usages\n    const promise = Storage.getAllKeys()\n        .then((keys) => {\n            _.each(keys, key => cache.addKey(key));\n            return keys;\n        });\n\n    return cache.captureTask(taskName, promise);\n}\n\n/**\n * Checks to see if the a subscriber's supplied key\n * is associated with a collection of keys.\n *\n * @private\n * @param {String} key\n * @returns {Boolean}\n */\nfunction isCollectionKey(key) {\n    return _.contains(_.values(onyxKeys.COLLECTION), key);\n}\n\n/**\n * Checks to see if a given key matches with the\n * configured key of our connected subscriber\n *\n * @private\n * @param {String} configKey\n * @param {String} key\n * @return {Boolean}\n */\nfunction isKeyMatch(configKey, key) {\n    return isCollectionKey(configKey)\n        ? Str.startsWith(key, configKey)\n        : configKey === key;\n}\n\n/**\n * Checks to see if this key has been flagged as\n * safe for removal.\n *\n * @private\n * @param {String} testKey\n * @returns {Boolean}\n */\nfunction isSafeEvictionKey(testKey) {\n    return _.some(evictionAllowList, key => isKeyMatch(key, testKey));\n}\n\n/**\n * Remove a key from the recently accessed key list.\n *\n * @private\n * @param {String} key\n */\nfunction removeLastAccessedKey(key) {\n    recentlyAccessedKeys = _.without(recentlyAccessedKeys, key);\n}\n\n/**\n * Add a key to the list of recently accessed keys. The least\n * recently accessed key should be at the head and the most\n * recently accessed key at the tail.\n *\n * @private\n * @param {String} key\n */\nfunction addLastAccessedKey(key) {\n    // Only specific keys belong in this list since we cannot remove an entire collection.\n    if (isCollectionKey(key) || !isSafeEvictionKey(key)) {\n        return;\n    }\n\n    removeLastAccessedKey(key);\n    recentlyAccessedKeys.push(key);\n}\n\n/**\n * Removes a key previously added to this list\n * which will enable it to be deleted again.\n *\n * @private\n * @param {String} key\n * @param {Number} connectionID\n */\nfunction removeFromEvictionBlockList(key, connectionID) {\n    evictionBlocklist[key] = _.without(evictionBlocklist[key] || [], connectionID);\n\n    // Remove the key if there are no more subscribers\n    if (evictionBlocklist[key].length === 0) {\n        delete evictionBlocklist[key];\n    }\n}\n\n/**\n * Keys added to this list can never be deleted.\n *\n * @private\n * @param {String} key\n * @param {Number} connectionID\n */\nfunction addToEvictionBlockList(key, connectionID) {\n    removeFromEvictionBlockList(key, connectionID);\n\n    if (!evictionBlocklist[key]) {\n        evictionBlocklist[key] = [];\n    }\n\n    evictionBlocklist[key].push(connectionID);\n}\n\n/**\n * Take all the keys that are safe to evict and add them to\n * the recently accessed list when initializing the app. This\n * enables keys that have not recently been accessed to be\n * removed.\n *\n * @private\n * @returns {Promise}\n */\nfunction addAllSafeEvictionKeysToRecentlyAccessedList() {\n    return getAllKeys()\n        .then((keys) => {\n            _.each(evictionAllowList, (safeEvictionKey) => {\n                _.each(keys, (key) => {\n                    if (isKeyMatch(safeEvictionKey, key)) {\n                        addLastAccessedKey(key);\n                    }\n                });\n            });\n        });\n}\n\n/**\n * @private\n * @param {String} collectionKey\n * @returns {Object}\n */\nfunction getCachedCollection(collectionKey) {\n    const collectionMemberKeys = _.filter(cache.getAllKeys(), (\n        storedKey => isKeyMatch(collectionKey, storedKey)\n    ));\n\n    return _.reduce(collectionMemberKeys, (prev, curr) => {\n        const cachedValue = cache.getValue(curr);\n        if (!cachedValue) {\n            return prev;\n        }\n        return ({\n            ...prev,\n            [curr]: cachedValue,\n        });\n    }, {});\n}\n\n/**\n * When a collection of keys change, search for any callbacks matching the collection key and trigger those callbacks\n *\n * @private\n * @param {String} collectionKey\n * @param {Object} collection\n */\nfunction keysChanged(collectionKey, collection) {\n    // Find all subscribers that were added with connect() and trigger the callback or setState() with the new data\n    _.each(callbackToStateMapping, (subscriber) => {\n        if (!subscriber) {\n            return;\n        }\n\n        const isSubscribedToCollectionKey = isKeyMatch(subscriber.key, collectionKey)\n            && isCollectionKey(subscriber.key);\n        const isSubscribedToCollectionMemberKey = subscriber.key.startsWith(collectionKey);\n\n        if (isSubscribedToCollectionKey) {\n            if (_.isFunction(subscriber.callback)) {\n                // eslint-disable-next-line no-use-before-define\n                const cachedCollection = getCachedCollection(collectionKey);\n                _.each(collection, (data, dataKey) => {\n                    subscriber.callback(cachedCollection[dataKey], dataKey);\n                });\n            } else if (subscriber.withOnyxInstance) {\n                subscriber.withOnyxInstance.setState((prevState) => {\n                    const finalCollection = _.clone(prevState[subscriber.statePropertyName] || {});\n                    _.each(collection, (data, dataKey) => {\n                        if (finalCollection[dataKey]) {\n                            lodashMerge(finalCollection[dataKey], data);\n                        } else {\n                            finalCollection[dataKey] = data;\n                        }\n                    });\n\n                    return {\n                        [subscriber.statePropertyName]: finalCollection,\n                    };\n                });\n            }\n        } else if (isSubscribedToCollectionMemberKey) {\n            const dataFromCollection = collection[subscriber.key];\n\n            // If `dataFromCollection` happens to not exist, then return early so that there are no unnecessary\n            // re-renderings of the component\n            if (_.isUndefined(dataFromCollection)) {\n                return;\n            }\n\n            subscriber.withOnyxInstance.setState(prevState => ({\n                [subscriber.statePropertyName]: _.isObject(dataFromCollection)\n                    ? {\n                        ...prevState[subscriber.statePropertyName],\n                        ...dataFromCollection,\n                    }\n                    : dataFromCollection,\n            }));\n        }\n    });\n}\n\n/**\n * When a key change happens, search for any callbacks matching the key or collection key and trigger those callbacks\n *\n * @private\n * @param {String} key\n * @param {*} data\n */\nfunction keyChanged(key, data) {\n    // Add or remove this key from the recentlyAccessedKeys lists\n    if (!_.isNull(data)) {\n        addLastAccessedKey(key);\n    } else {\n        removeLastAccessedKey(key);\n    }\n\n    // Find all subscribers that were added with connect() and trigger the callback or setState() with the new data\n    _.each(callbackToStateMapping, (subscriber) => {\n        if (subscriber && isKeyMatch(subscriber.key, key)) {\n            if (_.isFunction(subscriber.callback)) {\n                subscriber.callback(data, key);\n            }\n\n            if (!subscriber.withOnyxInstance) {\n                return;\n            }\n\n            // Check if we are subscribing to a collection key and add this item as a collection\n            if (isCollectionKey(subscriber.key)) {\n                subscriber.withOnyxInstance.setState((prevState) => {\n                    const collection = _.clone(prevState[subscriber.statePropertyName] || {});\n                    collection[key] = data;\n                    return {\n                        [subscriber.statePropertyName]: collection,\n                    };\n                });\n            } else {\n                subscriber.withOnyxInstance.setState({\n                    [subscriber.statePropertyName]: data,\n                });\n            }\n        }\n    });\n}\n\n/**\n * Sends the data obtained from the keys to the connection. It either:\n *     - sets state on the withOnyxInstances\n *     - triggers the callback function\n *\n * @private\n * @param {object} config\n * @param {object} [config.withOnyxInstance]\n * @param {string} [config.statePropertyName]\n * @param {function} [config.callback]\n * @param {*|null} val\n * @param {String} key\n */\nfunction sendDataToConnection(config, val, key) {\n    // If the mapping no longer exists then we should not send any data.\n    // This means our subscriber disconnected or withOnyx wrapped component unmounted.\n    if (!callbackToStateMapping[config.connectionID]) {\n        return;\n    }\n\n    if (config.withOnyxInstance) {\n        config.withOnyxInstance.setWithOnyxState(config.statePropertyName, val);\n    } else if (_.isFunction(config.callback)) {\n        config.callback(val, key);\n    }\n}\n\n/**\n * Subscribes a react component's state directly to a store key\n *\n * @example\n * const connectionID = Onyx.connect({\n *     key: ONYXKEYS.SESSION,\n *     callback: onSessionChange,\n * });\n *\n * @param {Object} mapping the mapping information to connect Onyx to the components state\n * @param {String} mapping.key ONYXKEY to subscribe to\n * @param {String} [mapping.statePropertyName] the name of the property in the state to connect the data to\n * @param {Object} [mapping.withOnyxInstance] whose setState() method will be called with any changed data\n *      This is used by React components to connect to Onyx\n * @param {Function} [mapping.callback] a method that will be called with changed data\n *      This is used by any non-React code to connect to Onyx\n * @param {Boolean} [mapping.initWithStoredValues] If set to false, then no data will be prefilled into the\n *  component\n * @returns {Number} an ID to use when calling disconnect\n */\nfunction connect(mapping) {\n    const connectionID = lastConnectionID++;\n    callbackToStateMapping[connectionID] = mapping;\n    callbackToStateMapping[connectionID].connectionID = connectionID;\n\n    if (mapping.initWithStoredValues === false) {\n        return connectionID;\n    }\n\n    // Commit connection only after init passes\n    deferredInitTask.promise\n        .then(() => {\n            // Check to see if this key is flagged as a safe eviction key and add it to the recentlyAccessedKeys list\n            if (isSafeEvictionKey(mapping.key)) {\n                // Try to free some cache whenever we connect to a safe eviction key\n                cache.removeLeastRecentlyUsedKeys();\n\n                if (mapping.withOnyxInstance && !isCollectionKey(mapping.key)) {\n                    // All React components subscribing to a key flagged as a safe eviction\n                    // key must implement the canEvict property.\n                    if (_.isUndefined(mapping.canEvict)) {\n                        throw new Error(\n                            `Cannot subscribe to safe eviction key '${mapping.key}' without providing a canEvict value.`\n                        );\n                    }\n\n                    addLastAccessedKey(mapping.key);\n                }\n            }\n        })\n        .then(getAllKeys)\n        .then((keys) => {\n            // Find all the keys matched by the config key\n            const matchingKeys = _.filter(keys, key => isKeyMatch(mapping.key, key));\n\n            // If the key being connected to does not exist, initialize the value with null\n            if (matchingKeys.length === 0) {\n                sendDataToConnection(mapping, null);\n                return;\n            }\n\n            // When using a callback subscriber we will trigger the callback\n            // for each key we find. It's up to the subscriber to know whether\n            // to expect a single key or multiple keys in the case of a collection.\n            // React components are an exception since we'll want to send their\n            // initial data as a single object when using collection keys.\n            if (mapping.withOnyxInstance && isCollectionKey(mapping.key)) {\n                Promise.all(_.map(matchingKeys, key => get(key)))\n                    .then(values => _.reduce(values, (finalObject, value, i) => ({\n                        ...finalObject,\n                        [matchingKeys[i]]: value,\n                    }), {}))\n                    .then(val => sendDataToConnection(mapping, val));\n            } else {\n                _.each(matchingKeys, (key) => {\n                    get(key).then(val => sendDataToConnection(mapping, val, key));\n                });\n            }\n        });\n\n    return connectionID;\n}\n\n/**\n * Remove the listener for a react component\n * @example\n * Onyx.disconnect(connectionID);\n *\n * @param {Number} connectionID unique id returned by call to Onyx.connect()\n * @param {String} [keyToRemoveFromEvictionBlocklist]\n */\nfunction disconnect(connectionID, keyToRemoveFromEvictionBlocklist) {\n    if (!callbackToStateMapping[connectionID]) {\n        return;\n    }\n\n    // Remove this key from the eviction block list as we are no longer\n    // subscribing to it and it should be safe to delete again\n    if (keyToRemoveFromEvictionBlocklist) {\n        removeFromEvictionBlockList(keyToRemoveFromEvictionBlocklist, connectionID);\n    }\n\n    delete callbackToStateMapping[connectionID];\n}\n\n/**\n * Remove a key from Onyx and update the subscribers\n *\n * @private\n * @param {String} key\n * @return {Promise}\n */\nfunction remove(key) {\n    // Cache the fact that the value was removed\n    cache.set(key, null);\n\n    // Optimistically inform subscribers on the next tick\n    Promise.resolve().then(() => keyChanged(key, null));\n\n    return Storage.removeItem(key);\n}\n\n/**\n * If we fail to set or merge we must handle this by\n * evicting some data from Onyx and then retrying to do\n * whatever it is we attempted to do.\n *\n * @private\n * @param {Error} error\n * @param {Function} onyxMethod\n * @param  {...any} args\n * @return {Promise}\n */\nfunction evictStorageAndRetry(error, onyxMethod, ...args) {\n    logInfo(`Handled error: ${error}`);\n\n    if (error && Str.startsWith(error.message, 'Failed to execute \\'put\\' on \\'IDBObjectStore\\'')) {\n        logAlert('Attempted to set invalid data set in Onyx. Please ensure all data is serializable.');\n        throw error;\n    }\n\n    // Find the first key that we can remove that has no subscribers in our blocklist\n    const keyForRemoval = _.find(recentlyAccessedKeys, key => !evictionBlocklist[key]);\n\n    if (!keyForRemoval) {\n        logAlert('Out of storage. But found no acceptable keys to remove.');\n        throw error;\n    }\n\n    // Remove the least recently viewed key that is not currently being accessed and retry.\n    logInfo(`Out of storage. Evicting least recently accessed key (${keyForRemoval}) and retrying.`);\n    return remove(keyForRemoval)\n        .then(() => onyxMethod(...args));\n}\n\n/**\n * Write a value to our store with the given key\n *\n * @param {String} key ONYXKEY to set\n * @param {*} value value to store\n *\n * @returns {Promise}\n */\nfunction set(key, value) {\n    // Logging properties only since values could be sensitive things we don't want to log\n    logInfo(`set() called for key: ${key}${_.isObject(value) ? ` properties: ${_.keys(value).join(',')}` : ''}`);\n\n    // eslint-disable-next-line no-use-before-define\n    if (hasPendingMergeForKey(key)) {\n        // eslint-disable-next-line max-len\n        logAlert(`Onyx.set() called after Onyx.merge() for key: ${key}. It is recommended to use set() or merge() not both.`);\n    }\n\n    // Adds the key to cache when it's not available\n    cache.set(key, value);\n\n    // Optimistically inform subscribers on the next tick\n    Promise.resolve().then(() => keyChanged(key, value));\n\n    // Write the thing to persistent storage, which will trigger a storage event for any other tabs open on this domain\n    return Storage.setItem(key, value)\n        .catch(error => evictStorageAndRetry(error, set, key, value));\n}\n\n/**\n * Storage expects array like: [[\"@MyApp_user\", value_1], [\"@MyApp_key\", value_2]]\n * This method transforms an object like {'@MyApp_user': myUserValue, '@MyApp_key': myKeyValue}\n * to an array of key-value pairs in the above format\n * @private\n * @param {Record} data\n * @return {Array} an array of key - value pairs <[key, value]>\n */\nfunction prepareKeyValuePairsForStorage(data) {\n    return _.map(data, (value, key) => [key, value]);\n}\n\n/**\n * Sets multiple keys and values\n *\n * @example Onyx.multiSet({'key1': 'a', 'key2': 'b'});\n *\n * @param {Object} data object keyed by ONYXKEYS and the values to set\n * @returns {Promise}\n */\nfunction multiSet(data) {\n    const keyValuePairs = prepareKeyValuePairsForStorage(data);\n\n    _.each(data, (val, key) => {\n        // Update cache and optimistically inform subscribers on the next tick\n        cache.set(key, val);\n        Promise.resolve().then(() => keyChanged(key, val));\n    });\n\n    return Storage.multiSet(keyValuePairs)\n        .catch(error => evictStorageAndRetry(error, multiSet, data));\n}\n\n// Key/value store of Onyx key and arrays of values to merge\nconst mergeQueue = {};\n\n/**\n * @private\n * @param {String} key\n * @returns {Boolean}\n */\nfunction hasPendingMergeForKey(key) {\n    return Boolean(mergeQueue[key]);\n}\n\n/**\n * Given an Onyx key and value this method will combine all queued\n * value updates and return a single value. Merge attempts are\n * batched. They must occur after a single call to get() so we\n * can avoid race conditions.\n *\n * @private\n * @param {String} key\n * @param {*} data\n *\n * @returns {*}\n */\nfunction applyMerge(key, data) {\n    const mergeValues = mergeQueue[key];\n    if (_.isArray(data) || _.every(mergeValues, _.isArray)) {\n        // Array values will always just concatenate\n        // more items onto the end of the array\n        return _.reduce(mergeValues, (modifiedData, mergeValue) => [\n            ...modifiedData,\n            ...mergeValue,\n        ], data || []);\n    }\n\n    if (_.isObject(data) || _.every(mergeValues, _.isObject)) {\n        // Object values are merged one after the other\n        return _.reduce(mergeValues, (modifiedData, mergeValue) => {\n            const newData = lodashMerge({}, modifiedData, mergeValue);\n\n            // We will also delete any object keys that are undefined or null.\n            // Deleting keys is not supported by AsyncStorage so we do it this way.\n            // Remove all first level keys that are explicitly set to null.\n            return _.omit(newData, (value, finalObjectKey) => _.isNull(mergeValue[finalObjectKey]));\n        }, data || {});\n    }\n\n    // If we have anything else we can't merge it so we'll\n    // simply return the last value that was queued\n    return _.last(mergeValues);\n}\n\n/**\n * Merge a new value into an existing value at a key.\n *\n * The types of values that can be merged are `Object` and `Array`. To set another type of value use `Onyx.set()`. Merge\n * behavior uses lodash/merge under the hood for `Object` and simple concatenation for `Array`. However, it's important\n * to note that if you have an array value property on an `Object` that the default behavior of lodash/merge is not to\n * concatenate. See here: https://github.com/lodash/lodash/issues/2872\n *\n * Calls to `Onyx.merge()` are batched so that any calls performed in a single tick will stack in a queue and get\n * applied in the order they were called. Note: `Onyx.set()` calls do not work this way so use caution when mixing\n * `Onyx.merge()` and `Onyx.set()`.\n *\n * @example\n * Onyx.merge(ONYXKEYS.EMPLOYEE_LIST, ['Joe']); // -> ['Joe']\n * Onyx.merge(ONYXKEYS.EMPLOYEE_LIST, ['Jack']); // -> ['Joe', 'Jack']\n * Onyx.merge(ONYXKEYS.POLICY, {id: 1}); // -> {id: 1}\n * Onyx.merge(ONYXKEYS.POLICY, {name: 'My Workspace'}); // -> {id: 1, name: 'My Workspace'}\n *\n * @param {String} key ONYXKEYS key\n * @param {(Object|Array)} value Object or Array value to merge\n * @returns {Promise}\n */\nfunction merge(key, value) {\n    if (mergeQueue[key]) {\n        mergeQueue[key].push(value);\n        return Promise.resolve();\n    }\n\n    mergeQueue[key] = [value];\n    return get(key)\n        .then((data) => {\n            try {\n                const modifiedData = applyMerge(key, data);\n\n                // Clean up the write queue so we\n                // don't apply these changes again\n                delete mergeQueue[key];\n\n                return set(key, modifiedData);\n            } catch (error) {\n                logAlert(`An error occurred while applying merge for key: ${key}, Error: ${error}`);\n            }\n\n            return Promise.resolve();\n        });\n}\n\n/**\n * Merge user provided default key value pairs.\n * @private\n * @returns {Promise}\n */\nfunction initializeWithDefaultKeyStates() {\n    return Storage.multiGet(_.keys(defaultKeyStates))\n        .then((pairs) => {\n            const asObject = _.object(pairs);\n\n            const merged = lodashMerge(asObject, defaultKeyStates);\n            cache.merge(merged);\n            _.each(merged, (val, key) => keyChanged(key, val));\n        });\n}\n\n/**\n * Clear out all the data in the store\n *\n * @returns {Promise<void>}\n */\nfunction clear() {\n    return getAllKeys()\n        .then((keys) => {\n            _.each(keys, (key) => {\n                keyChanged(key, null);\n                cache.set(key, null);\n            });\n        })\n        .then(Storage.clear)\n        .then(initializeWithDefaultKeyStates);\n}\n\n/**\n * Merges a collection based on their keys\n *\n * @example\n *\n * Onyx.mergeCollection(ONYXKEYS.COLLECTION.REPORT, {\n *     [`${ONYXKEYS.COLLECTION.REPORT}1`]: report1,\n *     [`${ONYXKEYS.COLLECTION.REPORT}2`]: report2,\n * });\n *\n * @param {String} collectionKey e.g. `ONYXKEYS.COLLECTION.REPORT`\n * @param {Object} collection Object collection keyed by individual collection member keys and values\n * @returns {Promise}\n */\nfunction mergeCollection(collectionKey, collection) {\n    // Confirm all the collection keys belong to the same parent\n    _.each(collection, (data, dataKey) => {\n        if (!isKeyMatch(collectionKey, dataKey)) {\n            // eslint-disable-next-line max-len\n            throw new Error(`Provided collection does not have all its data belonging to the same parent. CollectionKey: ${collectionKey}, DataKey: ${dataKey}`);\n        }\n    });\n\n    return getAllKeys()\n        .then((persistedKeys) => {\n            // Split to keys that exist in storage and keys that don't\n            const [existingKeys, newKeys] = _.chain(collection)\n                .keys()\n                .partition(key => persistedKeys.includes(key))\n                .value();\n\n            const existingKeyCollection = _.pick(collection, existingKeys);\n            const newCollection = _.pick(collection, newKeys);\n            const keyValuePairsForExistingCollection = prepareKeyValuePairsForStorage(existingKeyCollection);\n            const keyValuePairsForNewCollection = prepareKeyValuePairsForStorage(newCollection);\n\n            const promises = [];\n\n            // New keys will be added via multiSet while existing keys will be updated using multiMerge\n            // This is because setting a key that doesn't exist yet with multiMerge will throw errors\n            if (keyValuePairsForExistingCollection.length > 0) {\n                promises.push(Storage.multiMerge(keyValuePairsForExistingCollection));\n            }\n\n            if (keyValuePairsForNewCollection.length > 0) {\n                promises.push(Storage.multiSet(keyValuePairsForNewCollection));\n            }\n\n            // Prefill cache if necessary by calling get() on any existing keys and then merge original data to cache\n            // and update all subscribers\n            Promise.all(_.map(existingKeys, get)).then(() => {\n                cache.merge(collection);\n                keysChanged(collectionKey, collection);\n            });\n\n            return Promise.all(promises)\n                .catch(error => evictStorageAndRetry(error, mergeCollection, collection));\n        });\n}\n\n/**\n * Initialize the store with actions and listening for storage events\n *\n * @param {Object} [options={}] config object\n * @param {Object} [options.keys={}] `ONYXKEYS` constants object\n * @param {Object} [options.initialKeyStates={}] initial data to set when `init()` and `clear()` is called\n * @param {String[]} [options.safeEvictionKeys=[]] This is an array of keys\n * (individual or collection patterns) that when provided to Onyx are flagged\n * as \"safe\" for removal. Any components subscribing to these keys must also\n * implement a canEvict option. See the README for more info.\n * @param {Number} [options.maxCachedKeysCount=55] Sets how many recent keys should we try to keep in cache\n * Setting this to 0 would practically mean no cache\n * We try to free cache when we connect to a safe eviction key\n * @param {Boolean} [options.captureMetrics] Enables Onyx benchmarking and exposes the get/print/reset functions\n * @param {Boolean} [options.shouldSyncMultipleInstances] Auto synchronize storage events between multiple instances\n * of Onyx running in different tabs/windows. Defaults to true for platforms that support local storage (web/desktop)\n * @param {String[]} [option.keysToDisableSyncEvents=[]] Contains keys for which\n * we want to disable sync event across tabs.\n * @example\n * Onyx.init({\n *     keys: ONYXKEYS,\n *     initialKeyStates: {\n *         [ONYXKEYS.SESSION]: {loading: false},\n *     },\n * });\n */\nfunction init({\n    keys = {},\n    initialKeyStates = {},\n    safeEvictionKeys = [],\n    maxCachedKeysCount = 1000,\n    captureMetrics = false,\n    shouldSyncMultipleInstances = Boolean(global.localStorage),\n    keysToDisableSyncEvents = [],\n} = {}) {\n    if (captureMetrics) {\n        // The code here is only bundled and applied when the captureMetrics is set\n        // eslint-disable-next-line no-use-before-define\n        applyDecorators();\n    }\n\n    if (maxCachedKeysCount > 0) {\n        cache.setRecentKeysLimit(maxCachedKeysCount);\n    }\n\n    // Let Onyx know about all of our keys\n    onyxKeys = keys;\n\n    // Set our default key states to use when initializing and clearing Onyx data\n    defaultKeyStates = initialKeyStates;\n\n    // Let Onyx know about which keys are safe to evict\n    evictionAllowList = safeEvictionKeys;\n\n    // Initialize all of our keys with data provided then give green light to any pending connections\n    Promise.all([\n        addAllSafeEvictionKeysToRecentlyAccessedList(),\n        initializeWithDefaultKeyStates()\n    ])\n        .then(deferredInitTask.resolve);\n\n    if (shouldSyncMultipleInstances && _.isFunction(Storage.keepInstancesSync)) {\n        Storage.keepInstancesSync(keysToDisableSyncEvents, (key, value) => {\n            cache.set(key, value);\n            keyChanged(key, value);\n        });\n    }\n}\n\nconst Onyx = {\n    connect,\n    disconnect,\n    set,\n    multiSet,\n    merge,\n    mergeCollection,\n    clear,\n    init,\n    registerLogger,\n    addToEvictionBlockList,\n    removeFromEvictionBlockList,\n    isSafeEvictionKey,\n};\n\n/**\n * Apply calls statistic decorators to benchmark Onyx\n *\n * @private\n */\nfunction applyDecorators() {\n    // We're requiring the script dynamically here so that it's only evaluated when decorators are used\n    const decorate = require('./metrics');\n\n    // Re-assign with decorated functions\n    /* eslint-disable no-func-assign */\n    get = decorate.decorateWithMetrics(get, 'Onyx:get');\n    set = decorate.decorateWithMetrics(set, 'Onyx:set');\n    multiSet = decorate.decorateWithMetrics(multiSet, 'Onyx:multiSet');\n    clear = decorate.decorateWithMetrics(clear, 'Onyx:clear');\n    merge = decorate.decorateWithMetrics(merge, 'Onyx:merge');\n    mergeCollection = decorate.decorateWithMetrics(mergeCollection, 'Onyx:mergeCollection');\n    getAllKeys = decorate.decorateWithMetrics(getAllKeys, 'Onyx:getAllKeys');\n    initializeWithDefaultKeyStates = decorate.decorateWithMetrics(initializeWithDefaultKeyStates, 'Onyx:defaults');\n    /* eslint-enable */\n\n    // Re-expose decorated methods\n    Onyx.set = set;\n    Onyx.multiSet = multiSet;\n    Onyx.clear = clear;\n    Onyx.merge = merge;\n    Onyx.mergeCollection = mergeCollection;\n\n    // Expose stats methods on Onyx\n    Onyx.getMetrics = decorate.getMetrics;\n    Onyx.resetMetrics = decorate.resetMetrics;\n    Onyx.printMetrics = decorate.printMetrics;\n}\n\nexport default Onyx;\n","import _ from 'underscore';\nimport lodashMerge from 'lodash/merge';\n\n\nconst isDefined = _.negate(_.isUndefined);\n\n/**\n * In memory cache providing data by reference\n * Encapsulates Onyx cache related functionality\n */\nclass OnyxCache {\n    constructor() {\n        /**\n         * @private\n         * Cache of all the storage keys available in persistent storage\n         * @type {Set<string>}\n         */\n        this.storageKeys = new Set();\n\n        /**\n         * @private\n         * Unique list of keys maintained in access order (most recent at the end)\n         * @type {Set<string>}\n         */\n        this.recentKeys = new Set();\n\n        /**\n         * @private\n         * A map of cached values\n         * @type {Record<string, *>}\n         */\n        this.storageMap = {};\n\n        /**\n         * @private\n         * Captured pending tasks for already running storage methods\n         * @type {Record<string, Promise>}\n         */\n        this.pendingPromises = {};\n\n        // bind all public methods to prevent problems with `this`\n        _.bindAll(\n            this,\n            'getAllKeys', 'getValue', 'hasCacheForKey', 'addKey', 'set', 'drop', 'merge',\n            'hasPendingTask', 'getTaskPromise', 'captureTask', 'removeLeastRecentlyUsedKeys',\n            'setRecentKeysLimit'\n        );\n    }\n\n    /**\n     * Get all the storage keys\n     * @returns {string[]}\n     */\n    getAllKeys() {\n        return Array.from(this.storageKeys);\n    }\n\n    /**\n     * Get a cached value from storage\n     * @param {string} key\n     * @returns {*}\n     */\n    getValue(key) {\n        this.addToAccessedKeys(key);\n        return this.storageMap[key];\n    }\n\n    /**\n     * Check whether cache has data for the given key\n     * @param {string} key\n     * @returns {boolean}\n     */\n    hasCacheForKey(key) {\n        return isDefined(this.storageMap[key]);\n    }\n\n    /**\n     * Saves a key in the storage keys list\n     * Serves to keep the result of `getAllKeys` up to date\n     * @param {string} key\n     */\n    addKey(key) {\n        this.storageKeys.add(key);\n    }\n\n    /**\n     * Set's a key value in cache\n     * Adds the key to the storage keys list as well\n     * @param {string} key\n     * @param {*} value\n     * @returns {*} value - returns the cache value\n     */\n    set(key, value) {\n        this.addKey(key);\n        this.addToAccessedKeys(key);\n        this.storageMap[key] = value;\n\n        return value;\n    }\n\n    /**\n     * Forget the cached value for the given key\n     * @param {string} key\n     */\n    drop(key) {\n        delete this.storageMap[key];\n    }\n\n    /**\n     * Deep merge data to cache, any non existing keys will be created\n     * @param {Record<string, *>} data - a map of (cache) key - values\n     */\n    merge(data) {\n        this.storageMap = lodashMerge({}, this.storageMap, data);\n\n        const storageKeys = this.getAllKeys();\n        const mergedKeys = _.keys(data);\n        this.storageKeys = new Set([...storageKeys, ...mergedKeys]);\n        _.each(mergedKeys, key => this.addToAccessedKeys(key));\n    }\n\n    /**\n     * Check whether the given task is already running\n     * @param {string} taskName - unique name given for the task\n     * @returns {*}\n     */\n    hasPendingTask(taskName) {\n        return isDefined(this.pendingPromises[taskName]);\n    }\n\n    /**\n     * Use this method to prevent concurrent calls for the same thing\n     * Instead of calling the same task again use the existing promise\n     * provided from this function\n     * @template T\n     * @param {string} taskName - unique name given for the task\n     * @returns {Promise<T>}\n     */\n    getTaskPromise(taskName) {\n        return this.pendingPromises[taskName];\n    }\n\n    /**\n     * Capture a promise for a given task so other caller can\n     * hook up to the promise if it's still pending\n     * @template T\n     * @param {string} taskName - unique name for the task\n     * @param {Promise<T>} promise\n     * @returns {Promise<T>}\n     */\n    captureTask(taskName, promise) {\n        this.pendingPromises[taskName] = promise.finally(() => {\n            delete this.pendingPromises[taskName];\n        });\n\n        return this.pendingPromises[taskName];\n    }\n\n    /**\n     * @private\n     * Adds a key to the top of the recently accessed keys\n     * @param {string} key\n     */\n    addToAccessedKeys(key) {\n        // Removing and re-adding a key ensures it's at the end of the list\n        this.recentKeys.delete(key);\n        this.recentKeys.add(key);\n    }\n\n    /**\n     * Remove keys that don't fall into the range of recently used keys\n     */\n    removeLeastRecentlyUsedKeys() {\n        if (this.recentKeys.size > this.maxRecentKeysSize) {\n            // Get the last N keys by doing a negative slice\n            const recentlyAccessed = [...this.recentKeys].slice(-this.maxRecentKeysSize);\n            const storageKeys = _.keys(this.storageMap);\n            const keysToRemove = _.difference(storageKeys, recentlyAccessed);\n\n            _.each(keysToRemove, this.drop);\n        }\n    }\n\n    /**\n     * Set the recent keys list size\n     * @param {number} limit\n     */\n    setRecentKeysLimit(limit) {\n        this.maxRecentKeysSize = limit;\n    }\n}\n\nconst instance = new OnyxCache();\n\nexport default instance;\n","/**\n * Synchronous queue that can be used to ensure promise based tasks are run in sequence.\n * Pass to the constructor a function that returns a promise to run the task then add data.\n *\n * @example\n *\n *     const queue = new SyncQueue(({key, val}) => {\n *         return someAsyncProcess(key, val);\n *     });\n *\n *     queue.push({key: 1, val: '1'});\n *     queue.push({key: 2, val: '2'});\n */\nexport default class SyncQueue {\n    /**\n     * @param {Function} run - must return a promise\n     */\n    constructor(run) {\n        this.queue = [];\n        this.isProcessing = false;\n        this.run = run;\n    }\n\n    process() {\n        if (this.isProcessing || this.queue.length === 0) {\n            return;\n        }\n\n        this.isProcessing = true;\n\n        const {data, resolve, reject} = this.queue.shift();\n        this.run(data)\n            .then(resolve)\n            .catch(reject)\n            .finally(() => {\n                this.isProcessing = false;\n                this.process();\n            });\n    }\n\n    /**\n     * @param {*} data\n     * @returns {Promise}\n     */\n    push(data) {\n        return new Promise((resolve, reject) => {\n            this.queue.push({resolve, reject, data});\n            this.process();\n        });\n    }\n}\n","/**\n * Create a deferred task that can be resolved when we call `resolve()`\n * The returned promise will complete when we call `resolve`\n * Useful when we want to wait for a tasks that is resolved from an external action\n *\n * @template T\n * @returns {{ resolve: function(*), promise: Promise<T|void> }}\n */\nexport default function createDeferredTask() {\n    const deferred = {};\n    deferred.promise = new Promise((res) => {\n        deferred.resolve = res;\n    });\n\n    return deferred;\n}\n","// For web-only implementations of Onyx, this module will just be a no-op\n\nfunction decorateWithMetrics() {}\nfunction getMetrics() {}\nfunction printMetrics() {}\nfunction resetMetrics() {}\n\nexport {\n    decorateWithMetrics,\n    getMetrics,\n    resetMetrics,\n    printMetrics,\n};\n","import _ from 'underscore';\nimport Storage from './providers/LocalForage';\n\nconst SYNC_ONYX = 'SYNC_ONYX';\n\n/**\n * Raise an event thorough `localStorage` to let other tabs know a value changed\n * @param {String} onyxKey\n */\nfunction raiseStorageSyncEvent(onyxKey) {\n    global.localStorage.setItem(SYNC_ONYX, onyxKey);\n    global.localStorage.removeItem(SYNC_ONYX, onyxKey);\n}\n\nconst webStorage = {\n    ...Storage,\n\n    /**\n     * Contains keys for which we want to disable sync event across tabs.\n     * @param {String[]} keysToDisableSyncEvents\n     * Storage synchronization mechanism keeping all opened tabs in sync\n     * @param {function(key: String, data: *)} onStorageKeyChanged\n     */\n    keepInstancesSync(keysToDisableSyncEvents, onStorageKeyChanged) {\n        // Override set, remove and clear to raise storage events that we intercept in other tabs\n        this.setItem = (key, value) => Storage.setItem(key, value)\n            .then(() => raiseStorageSyncEvent(key));\n\n        this.removeItem = key => Storage.removeItem(key)\n            .then(() => raiseStorageSyncEvent(key));\n\n        // If we just call Storage.clear other tabs will have no idea which keys were available previously\n        // so that they can call keysChanged for them. That's why we iterate and remove keys one by one\n        this.clear = () => Storage.getAllKeys()\n            .then(keys => _.map(keys, key => this.removeItem(key)))\n            .then(tasks => Promise.all(tasks));\n\n        // This listener will only be triggered by events coming from other tabs\n        global.addEventListener('storage', (event) => {\n            // Ignore events that don't originate from the SYNC_ONYX logic\n            if (event.key !== SYNC_ONYX || !event.newValue) {\n                return;\n            }\n\n            const onyxKey = event.newValue;\n            if (_.contains(keysToDisableSyncEvents, onyxKey)) {\n                return;\n            }\n\n            Storage.getItem(onyxKey)\n                .then(value => onStorageKeyChanged(onyxKey, value));\n        });\n    },\n};\n\nexport default webStorage;\n","import WebStorage from './WebStorage';\n\nexport default WebStorage;\n","/**\n * @file\n * The storage provider based on localforage allows us to store most anything in its\n * natural form in the underlying DB without having to stringify or de-stringify it\n */\n\nimport localforage from 'localforage';\nimport _ from 'underscore';\nimport lodashMerge from 'lodash/merge';\nimport SyncQueue from '../../SyncQueue';\n\nlocalforage.config({\n    name: 'OnyxDB'\n});\n\nconst provider = {\n    /**\n     * Writing very quickly to IndexedDB causes performance issues and can lock up the page and lead to jank.\n     * So, we are slowing this process down by waiting until one write is complete before moving on\n     * to the next.\n     */\n    setItemQueue: new SyncQueue(({key, value, shouldMerge}) => {\n        if (shouldMerge) {\n            return localforage.getItem(key)\n                .then((existingValue) => {\n                    const newValue = _.isObject(existingValue)\n                        ? lodashMerge({}, existingValue, value)\n                        : value;\n                    return localforage.setItem(key, newValue);\n                });\n        }\n\n        return localforage.setItem(key, value);\n    }),\n\n    /**\n     * Get multiple key-value pairs for the give array of keys in a batch\n     * @param {String[]} keys\n     * @return {Promise<Array<[key, value]>>}\n     */\n    multiGet(keys) {\n        const pairs = _.map(\n            keys,\n            key => localforage.getItem(key)\n                .then(value => [key, value])\n        );\n\n        return Promise.all(pairs);\n    },\n\n    /**\n     * Multiple merging of existing and new values in a batch\n     * @param {Array<[key, value]>} pairs\n     * @return {Promise<void>}\n     */\n    multiMerge(pairs) {\n        const tasks = _.map(pairs, ([key, value]) => this.setItemQueue.push({key, value, shouldMerge: true}));\n\n        // We're returning Promise.resolve, otherwise the array of task results will be returned to the caller\n        return Promise.all(tasks).then(() => Promise.resolve());\n    },\n\n    /**\n     * Stores multiple key-value pairs in a batch\n     * @param {Array<[key, value]>} pairs\n     * @return {Promise<void>}\n     */\n    multiSet(pairs) {\n        // We're returning Promise.resolve, otherwise the array of task results will be returned to the caller\n        const tasks = _.map(pairs, ([key, value]) => this.setItem(key, value));\n        return Promise.all(tasks).then(() => Promise.resolve());\n    },\n\n    /**\n     * Clear absolutely everything from storage\n     * @returns {Promise<void>}\n     */\n    clear: localforage.clear,\n\n    /**\n     * Returns all keys available in storage\n     * @returns {Promise<String[]>}\n     */\n    getAllKeys: localforage.keys,\n\n    /**\n     * Get the value of a given key or return `null` if it's not available in storage\n     * @param {String} key\n     * @return {Promise<*>}\n     */\n    getItem: localforage.getItem,\n\n    /**\n     * Remove given key and it's value from storage\n     * @param {String} key\n     * @returns {Promise<void>}\n     */\n    removeItem: localforage.removeItem,\n\n    /**\n     * Sets the value for a given key. The only requirement is that the value should be serializable to JSON string\n     * @param {String} key\n     * @param {*} value\n     * @return {Promise<void>}\n     */\n    setItem(key, value) {\n        return this.setItemQueue.push({key, value});\n    },\n};\n\nexport default provider;\n","/**\n * This is a higher order component that provides the ability to map a state property directly to\n * something in Onyx (a key/value store). That way, as soon as data in Onyx changes, the state will be set and the view\n * will automatically change to reflect the new data.\n */\nimport React from 'react';\nimport _ from 'underscore';\nimport PropTypes from 'prop-types';\nimport Str from 'expensify-common/lib/str';\nimport Onyx from './Onyx';\n\n/**\n * Returns the display name of a component\n *\n * @param {object} component\n * @returns {string}\n */\nfunction getDisplayName(component) {\n    return component.displayName || component.name || 'Component';\n}\n\nexport default function (mapOnyxToState) {\n    // A list of keys that must be present in tempState before we can render the WrappedComponent\n    const requiredKeysForInit = _.chain(mapOnyxToState)\n        .omit(config => config.initWithStoredValues === false)\n        .keys()\n        .value();\n\n    return (WrappedComponent) => {\n        class withOnyx extends React.Component {\n            constructor(props) {\n                super(props);\n\n                this.setWithOnyxState = this.setWithOnyxState.bind(this);\n\n                // This stores all the Onyx connection IDs to be used when the component unmounts so everything can be\n                // disconnected. It is a key value store with the format {[mapping.key]: connectionID}.\n                this.activeConnectionIDs = {};\n\n                // Object holding the temporary initial state for the component while we load the various Onyx keys\n                this.tempState = {};\n\n                this.state = {\n                    // If there are no required keys for init then we can render the wrapped component immediately\n                    loading: requiredKeysForInit.length > 0,\n                };\n            }\n\n            componentDidMount() {\n                // Subscribe each of the state properties to the proper Onyx key\n                _.each(mapOnyxToState, (mapping, propertyName) => {\n                    this.connectMappingToOnyx(mapping, propertyName);\n                });\n                this.checkEvictableKeys();\n            }\n\n            componentDidUpdate(prevProps) {\n                // If any of the mappings use data from the props, then when the props change, all the\n                // connections need to be reconnected with the new props\n                _.each(mapOnyxToState, (mapping, propertyName) => {\n                    const previousKey = Str.result(mapping.key, prevProps);\n                    const newKey = Str.result(mapping.key, this.props);\n\n                    if (previousKey !== newKey) {\n                        Onyx.disconnect(this.activeConnectionIDs[previousKey], previousKey);\n                        delete this.activeConnectionIDs[previousKey];\n                        this.connectMappingToOnyx(mapping, propertyName);\n                    }\n                });\n                this.checkEvictableKeys();\n            }\n\n            componentWillUnmount() {\n                // Disconnect everything from Onyx\n                _.each(mapOnyxToState, (mapping) => {\n                    const key = Str.result(mapping.key, this.props);\n                    const connectionID = this.activeConnectionIDs[key];\n                    Onyx.disconnect(connectionID, key);\n                });\n            }\n\n            /**\n             * This method is used externally by sendDataToConnection to prevent unnecessary renders while a component\n             * still in a loading state. The temporary initial state is saved to the component instance and setState()\n             * only called once all the necessary data has been collected.\n             *\n             * @param {String} statePropertyName\n             * @param {*} val\n             */\n            setWithOnyxState(statePropertyName, val) {\n                if (!this.state.loading) {\n                    this.setState({[statePropertyName]: val});\n                    return;\n                }\n\n                this.tempState[statePropertyName] = val;\n\n                // All state keys should exist and at least have a value of null\n                if (_.some(requiredKeysForInit, key => _.isUndefined(this.tempState[key]))) {\n                    return;\n                }\n\n                this.setState({...this.tempState, loading: false});\n                delete this.tempState;\n            }\n\n            /**\n             * Makes sure each Onyx key we requested has been set to state with a value of some kind.\n             * We are doing this so that the wrapped component will only render when all the data\n             * it needs is available to it.\n             */\n            checkEvictableKeys() {\n                // We will add this key to our list of recently accessed keys\n                // if the canEvict function returns true. This is necessary criteria\n                // we MUST use to specify if a key can be removed or not.\n                _.each(mapOnyxToState, (mapping) => {\n                    if (_.isUndefined(mapping.canEvict)) {\n                        return;\n                    }\n\n                    const canEvict = Str.result(mapping.canEvict, this.props);\n                    const key = Str.result(mapping.key, this.props);\n\n                    if (!Onyx.isSafeEvictionKey(key)) {\n                        // eslint-disable-next-line max-len\n                        throw new Error(`canEvict cannot be used on key '${key}'. This key must explicitly be flagged as safe for removal by adding it to Onyx.init({safeEvictionKeys: []}).`);\n                    }\n\n                    if (canEvict) {\n                        Onyx.removeFromEvictionBlockList(key, mapping.connectionID);\n                    } else {\n                        Onyx.addToEvictionBlockList(key, mapping.connectionID);\n                    }\n                });\n            }\n\n            /**\n             * Takes a single mapping and binds the state of the component to the store\n             *\n             * @param {object} mapping\n             * @param {string|function} mapping.key key to connect to. can be a string or a\n             * function that takes this.props as an argument and returns a string\n             * @param {string} statePropertyName the name of the state property that Onyx will add the data to\n             * @param {boolean} [mapping.initWithStoredValues] If set to false, then no data will be prefilled into the\n             *  component\n             */\n            connectMappingToOnyx(mapping, statePropertyName) {\n                const key = Str.result(mapping.key, this.props);\n\n                this.activeConnectionIDs[key] = Onyx.connect({\n                    ...mapping,\n                    key,\n                    statePropertyName,\n                    withOnyxInstance: this,\n                });\n            }\n\n            render() {\n                if (this.state.loading) {\n                    return null;\n                }\n\n                // Remove any internal state properties used by withOnyx\n                // that should not be passed to a wrapped component\n                let stateToPass = _.omit(this.state, 'loading');\n                stateToPass = _.omit(stateToPass, value => _.isNull(value));\n\n                // Remove any null values so that React replaces them with default props\n                const propsToPass = _.omit(this.props, value => _.isNull(value));\n\n                // Spreading props and state is necessary in an HOC where the data cannot be predicted\n                return (\n                    <WrappedComponent\n                        // eslint-disable-next-line react/jsx-props-no-spreading\n                        {...propsToPass}\n                        // eslint-disable-next-line react/jsx-props-no-spreading\n                        {...stateToPass}\n                        ref={this.props.forwardedRef}\n                    />\n                );\n            }\n        }\n\n        withOnyx.propTypes = {\n            forwardedRef: PropTypes.oneOfType([\n                PropTypes.func,\n                PropTypes.shape({current: PropTypes.instanceOf(React.Component)}),\n            ]),\n        };\n        withOnyx.defaultProps = {\n            forwardedRef: undefined,\n        };\n        withOnyx.displayName = `withOnyx(${getDisplayName(WrappedComponent)})`;\n        return React.forwardRef((props, ref) => {\n            const Component = withOnyx;\n            // eslint-disable-next-line react/jsx-props-no-spreading\n            return <Component {...props} forwardedRef={ref} />;\n        });\n    };\n}\n","/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nvar ReactPropTypesSecret = require('./lib/ReactPropTypesSecret');\n\nfunction emptyFunction() {}\nfunction emptyFunctionWithReset() {}\nemptyFunctionWithReset.resetWarningCache = emptyFunction;\n\nmodule.exports = function() {\n  function shim(props, propName, componentName, location, propFullName, secret) {\n    if (secret === ReactPropTypesSecret) {\n      // It is still safe when called from React.\n      return;\n    }\n    var err = new Error(\n      'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +\n      'Use PropTypes.checkPropTypes() to call them. ' +\n      'Read more at http://fb.me/use-check-prop-types'\n    );\n    err.name = 'Invariant Violation';\n    throw err;\n  };\n  shim.isRequired = shim;\n  function getShim() {\n    return shim;\n  };\n  // Important!\n  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.\n  var ReactPropTypes = {\n    array: shim,\n    bool: shim,\n    func: shim,\n    number: shim,\n    object: shim,\n    string: shim,\n    symbol: shim,\n\n    any: shim,\n    arrayOf: getShim,\n    element: shim,\n    elementType: shim,\n    instanceOf: getShim,\n    node: shim,\n    objectOf: getShim,\n    oneOf: getShim,\n    oneOfType: getShim,\n    shape: getShim,\n    exact: getShim,\n\n    checkPropTypes: emptyFunctionWithReset,\n    resetWarningCache: emptyFunction\n  };\n\n  ReactPropTypes.PropTypes = ReactPropTypes;\n\n  return ReactPropTypes;\n};\n","/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nif (process.env.NODE_ENV !== 'production') {\n  var ReactIs = require('react-is');\n\n  // By explicitly using `prop-types` you are opting into new development behavior.\n  // http://fb.me/prop-types-in-prod\n  var throwOnDirectAccess = true;\n  module.exports = require('./factoryWithTypeCheckers')(ReactIs.isElement, throwOnDirectAccess);\n} else {\n  // By explicitly using `prop-types` you are opting into new production behavior.\n  // http://fb.me/prop-types-in-prod\n  module.exports = require('./factoryWithThrowingShims')();\n}\n","/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nvar ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';\n\nmodule.exports = ReactPropTypesSecret;\n","module.exports = __WEBPACK_EXTERNAL_MODULE__97__;","module.exports = __WEBPACK_EXTERNAL_MODULE__349__;","module.exports = __WEBPACK_EXTERNAL_MODULE__179__;","module.exports = __WEBPACK_EXTERNAL_MODULE__156__;","module.exports = __WEBPACK_EXTERNAL_MODULE__952__;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","import Onyx from './lib/Onyx';\nimport withOnyx from './lib/withOnyx';\n\nexport default Onyx;\nexport {withOnyx};\n"],"names":["root","factory","exports","module","require","define","amd","self","__WEBPACK_EXTERNAL_MODULE__952__","__WEBPACK_EXTERNAL_MODULE__97__","__WEBPACK_EXTERNAL_MODULE__179__","__WEBPACK_EXTERNAL_MODULE__349__","__WEBPACK_EXTERNAL_MODULE__156__","arr","len","length","i","arr2","Array","isArray","arrayLikeToArray","ReferenceError","instance","Constructor","TypeError","_defineProperties","target","props","descriptor","enumerable","configurable","writable","Object","defineProperty","key","protoProps","staticProps","prototype","obj","value","_extends","assign","arguments","source","hasOwnProperty","call","apply","this","_getPrototypeOf","o","setPrototypeOf","getPrototypeOf","__proto__","subClass","superClass","create","constructor","__esModule","iter","Symbol","iterator","from","_arr","_n","_d","_e","undefined","_s","_i","next","done","push","err","_typeof","assertThisInitialized","_setPrototypeOf","p","arrayWithHoles","iterableToArrayLimit","unsupportedIterableToArray","nonIterableRest","arrayWithoutHoles","iterableToArray","nonIterableSpread","minLen","n","toString","slice","name","test","callback","logger","message","level","lastConnectionID","callbackToStateMapping","onyxKeys","recentlyAccessedKeys","evictionAllowList","evictionBlocklist","defaultKeyStates","deferredInitTask","get","cache","hasCacheForKey","Promise","resolve","getValue","taskName","hasPendingTask","getTaskPromise","promise","Storage","getItem","then","val","set","catch","logInfo","captureTask","getAllKeys","storedKeys","keys","_","each","addKey","isCollectionKey","contains","values","COLLECTION","isKeyMatch","configKey","Str","startsWith","isSafeEvictionKey","testKey","some","removeLastAccessedKey","without","addLastAccessedKey","removeFromEvictionBlockList","connectionID","addAllSafeEvictionKeysToRecentlyAccessedList","safeEvictionKey","keyChanged","data","isNull","subscriber","isFunction","withOnyxInstance","setState","prevState","collection","clone","statePropertyName","sendDataToConnection","config","setWithOnyxState","remove","removeItem","evictStorageAndRetry","error","onyxMethod","args","logAlert","keyForRemoval","find","isObject","join","Boolean","mergeQueue","hasPendingMergeForKey","setItem","prepareKeyValuePairsForStorage","map","multiSet","keyValuePairs","merge","modifiedData","mergeValues","every","reduce","mergeValue","newData","omit","finalObjectKey","last","applyMerge","initializeWithDefaultKeyStates","multiGet","pairs","asObject","object","merged","clear","mergeCollection","collectionKey","dataKey","Error","persistedKeys","chain","partition","includes","existingKeys","newKeys","existingKeyCollection","pick","newCollection","keyValuePairsForExistingCollection","keyValuePairsForNewCollection","promises","multiMerge","all","isSubscribedToCollectionKey","isSubscribedToCollectionMemberKey","cachedCollection","collectionMemberKeys","filter","storedKey","prev","curr","cachedValue","getCachedCollection","finalCollection","dataFromCollection","isUndefined","keysChanged","Onyx","connect","mapping","initWithStoredValues","removeLeastRecentlyUsedKeys","canEvict","matchingKeys","finalObject","disconnect","keyToRemoveFromEvictionBlocklist","init","initialKeyStates","safeEvictionKeys","maxCachedKeysCount","captureMetrics","shouldSyncMultipleInstances","global","localStorage","keysToDisableSyncEvents","applyDecorators","setRecentKeysLimit","keepInstancesSync","registerLogger","addToEvictionBlockList","decorate","decorateWithMetrics","getMetrics","resetMetrics","printMetrics","isDefined","negate","OnyxCache","storageKeys","Set","recentKeys","storageMap","pendingPromises","bindAll","addToAccessedKeys","add","mergedKeys","finally","delete","size","maxRecentKeysSize","recentlyAccessed","keysToRemove","difference","drop","limit","SyncQueue","run","queue","isProcessing","shift","reject","process","deferred","res","SYNC_ONYX","raiseStorageSyncEvent","onyxKey","onStorageKeyChanged","tasks","addEventListener","event","newValue","webStorage","WebStorage","localforage","setItemQueue","shouldMerge","existingValue","provider","mapOnyxToState","requiredKeysForInit","WrappedComponent","component","withOnyx","bind","activeConnectionIDs","tempState","state","loading","propertyName","connectMappingToOnyx","checkEvictableKeys","prevProps","previousKey","result","stateToPass","propsToPass","ref","forwardedRef","React","Component","propTypes","PropTypes","oneOfType","func","shape","current","instanceOf","defaultProps","displayName","forwardRef","ReactPropTypesSecret","emptyFunction","emptyFunctionWithReset","resetWarningCache","shim","propName","componentName","location","propFullName","secret","getShim","isRequired","ReactPropTypes","array","bool","number","string","symbol","any","arrayOf","element","elementType","node","objectOf","oneOf","exact","checkPropTypes","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","g","globalThis","Function","e","window"],"sourceRoot":""}