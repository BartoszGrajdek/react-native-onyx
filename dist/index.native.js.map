{"version":3,"file":"index.native.js","mappings":"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","sources":["webpack://react-native-onyx/webpack/universalModuleDefinition","webpack://react-native-onyx/./node_modules/@babel/runtime/helpers/arrayLikeToArray.js","webpack://react-native-onyx/./node_modules/@babel/runtime/helpers/arrayWithHoles.js","webpack://react-native-onyx/./node_modules/@babel/runtime/helpers/arrayWithoutHoles.js","webpack://react-native-onyx/./node_modules/@babel/runtime/helpers/assertThisInitialized.js","webpack://react-native-onyx/./node_modules/@babel/runtime/helpers/classCallCheck.js","webpack://react-native-onyx/./node_modules/@babel/runtime/helpers/createClass.js","webpack://react-native-onyx/./node_modules/@babel/runtime/helpers/defineProperty.js","webpack://react-native-onyx/./node_modules/@babel/runtime/helpers/extends.js","webpack://react-native-onyx/./node_modules/@babel/runtime/helpers/get.js","webpack://react-native-onyx/./node_modules/@babel/runtime/helpers/getPrototypeOf.js","webpack://react-native-onyx/./node_modules/@babel/runtime/helpers/inherits.js","webpack://react-native-onyx/./node_modules/@babel/runtime/helpers/interopRequireDefault.js","webpack://react-native-onyx/./node_modules/@babel/runtime/helpers/iterableToArray.js","webpack://react-native-onyx/./node_modules/@babel/runtime/helpers/iterableToArrayLimit.js","webpack://react-native-onyx/./node_modules/@babel/runtime/helpers/nonIterableRest.js","webpack://react-native-onyx/./node_modules/@babel/runtime/helpers/nonIterableSpread.js","webpack://react-native-onyx/./node_modules/@babel/runtime/helpers/objectWithoutProperties.js","webpack://react-native-onyx/./node_modules/@babel/runtime/helpers/objectWithoutPropertiesLoose.js","webpack://react-native-onyx/./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js","webpack://react-native-onyx/./node_modules/@babel/runtime/helpers/setPrototypeOf.js","webpack://react-native-onyx/./node_modules/@babel/runtime/helpers/slicedToArray.js","webpack://react-native-onyx/./node_modules/@babel/runtime/helpers/superPropBase.js","webpack://react-native-onyx/./node_modules/@babel/runtime/helpers/toConsumableArray.js","webpack://react-native-onyx/./node_modules/@babel/runtime/helpers/typeof.js","webpack://react-native-onyx/./node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js","webpack://react-native-onyx/./lib/Logger.js","webpack://react-native-onyx/./lib/MDTable.js","webpack://react-native-onyx/./lib/Onyx.js","webpack://react-native-onyx/./lib/OnyxCache.js","webpack://react-native-onyx/./lib/SyncQueue.js","webpack://react-native-onyx/./lib/createDeferredTask.js","webpack://react-native-onyx/./lib/metrics/index.native.js","webpack://react-native-onyx/./lib/storage/NativeStorage.js","webpack://react-native-onyx/./lib/storage/WebStorage.js","webpack://react-native-onyx/./lib/storage/index.native.js","webpack://react-native-onyx/./lib/storage/providers/AsyncStorage.js","webpack://react-native-onyx/./lib/storage/providers/LocalForage.js","webpack://react-native-onyx/./lib/withOnyx.js","webpack://react-native-onyx/./node_modules/prop-types/factoryWithThrowingShims.js","webpack://react-native-onyx/./node_modules/prop-types/index.js","webpack://react-native-onyx/./node_modules/prop-types/lib/ReactPropTypesSecret.js","webpack://react-native-onyx/external umd \"@react-native-async-storage/async-storage\"","webpack://react-native-onyx/external umd \"ascii-table\"","webpack://react-native-onyx/external umd \"expensify-common/lib/str\"","webpack://react-native-onyx/external umd \"localforage\"","webpack://react-native-onyx/external umd \"lodash/merge\"","webpack://react-native-onyx/external umd \"react\"","webpack://react-native-onyx/external umd \"react-native\"","webpack://react-native-onyx/external umd \"react-native-performance\"","webpack://react-native-onyx/external umd \"underscore\"","webpack://react-native-onyx/webpack/bootstrap","webpack://react-native-onyx/webpack/runtime/global","webpack://react-native-onyx/./index.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"underscore\"), require(\"expensify-common/lib/str\"), require(\"lodash/merge\"), require(\"react-native\"), require(\"localforage\"), require(\"@react-native-async-storage/async-storage\"), require(\"react-native-performance\"), require(\"ascii-table\"), require(\"react\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"underscore\", \"expensify-common/lib/str\", \"lodash/merge\", \"react-native\", \"localforage\", \"@react-native-async-storage/async-storage\", \"react-native-performance\", \"ascii-table\", \"react\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"react-native-onyx\"] = factory(require(\"underscore\"), require(\"expensify-common/lib/str\"), require(\"lodash/merge\"), require(\"react-native\"), require(\"localforage\"), require(\"@react-native-async-storage/async-storage\"), require(\"react-native-performance\"), require(\"ascii-table\"), require(\"react\"));\n\telse\n\t\troot[\"react-native-onyx\"] = factory(root[\"underscore\"], root[\"expensify-common/lib/str\"], root[\"lodash/merge\"], root[\"react-native\"], root[\"localforage\"], root[\"@react-native-async-storage/async-storage\"], root[\"react-native-performance\"], root[\"ascii-table\"], root[\"react\"]);\n})(self, (__WEBPACK_EXTERNAL_MODULE__4952__, __WEBPACK_EXTERNAL_MODULE__6097__, __WEBPACK_EXTERNAL_MODULE__9179__, __WEBPACK_EXTERNAL_MODULE__9925__, __WEBPACK_EXTERNAL_MODULE__3349__, __WEBPACK_EXTERNAL_MODULE__6878__, __WEBPACK_EXTERNAL_MODULE__3136__, __WEBPACK_EXTERNAL_MODULE__3246__, __WEBPACK_EXTERNAL_MODULE__8156__) => {\nreturn ","function _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nmodule.exports = _arrayLikeToArray;","function _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nmodule.exports = _arrayWithHoles;","var arrayLikeToArray = require(\"./arrayLikeToArray\");\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return arrayLikeToArray(arr);\n}\n\nmodule.exports = _arrayWithoutHoles;","function _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nmodule.exports = _assertThisInitialized;","function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nmodule.exports = _classCallCheck;","function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nmodule.exports = _createClass;","function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nmodule.exports = _defineProperty;","function _extends() {\n  module.exports = _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nmodule.exports = _extends;","var superPropBase = require(\"./superPropBase\");\n\nfunction _get(target, property, receiver) {\n  if (typeof Reflect !== \"undefined\" && Reflect.get) {\n    module.exports = _get = Reflect.get;\n  } else {\n    module.exports = _get = function _get(target, property, receiver) {\n      var base = superPropBase(target, property);\n      if (!base) return;\n      var desc = Object.getOwnPropertyDescriptor(base, property);\n\n      if (desc.get) {\n        return desc.get.call(receiver);\n      }\n\n      return desc.value;\n    };\n  }\n\n  return _get(target, property, receiver || target);\n}\n\nmodule.exports = _get;","function _getPrototypeOf(o) {\n  module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nmodule.exports = _getPrototypeOf;","var setPrototypeOf = require(\"./setPrototypeOf\");\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) setPrototypeOf(subClass, superClass);\n}\n\nmodule.exports = _inherits;","function _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nmodule.exports = _interopRequireDefault;","function _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nmodule.exports = _iterableToArray;","function _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nmodule.exports = _iterableToArrayLimit;","function _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nmodule.exports = _nonIterableRest;","function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nmodule.exports = _nonIterableSpread;","var objectWithoutPropertiesLoose = require(\"./objectWithoutPropertiesLoose\");\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nmodule.exports = _objectWithoutProperties;","function _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nmodule.exports = _objectWithoutPropertiesLoose;","var _typeof = require(\"@babel/runtime/helpers/typeof\");\n\nvar assertThisInitialized = require(\"./assertThisInitialized\");\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return assertThisInitialized(self);\n}\n\nmodule.exports = _possibleConstructorReturn;","function _setPrototypeOf(o, p) {\n  module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nmodule.exports = _setPrototypeOf;","var arrayWithHoles = require(\"./arrayWithHoles\");\n\nvar iterableToArrayLimit = require(\"./iterableToArrayLimit\");\n\nvar unsupportedIterableToArray = require(\"./unsupportedIterableToArray\");\n\nvar nonIterableRest = require(\"./nonIterableRest\");\n\nfunction _slicedToArray(arr, i) {\n  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();\n}\n\nmodule.exports = _slicedToArray;","var getPrototypeOf = require(\"./getPrototypeOf\");\n\nfunction _superPropBase(object, property) {\n  while (!Object.prototype.hasOwnProperty.call(object, property)) {\n    object = getPrototypeOf(object);\n    if (object === null) break;\n  }\n\n  return object;\n}\n\nmodule.exports = _superPropBase;","var arrayWithoutHoles = require(\"./arrayWithoutHoles\");\n\nvar iterableToArray = require(\"./iterableToArray\");\n\nvar unsupportedIterableToArray = require(\"./unsupportedIterableToArray\");\n\nvar nonIterableSpread = require(\"./nonIterableSpread\");\n\nfunction _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();\n}\n\nmodule.exports = _toConsumableArray;","function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    module.exports = _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    module.exports = _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nmodule.exports = _typeof;","var arrayLikeToArray = require(\"./arrayLikeToArray\");\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}\n\nmodule.exports = _unsupportedIterableToArray;","// Logging callback\nlet logger = () => {};\n\n/**\n * Register the logging callback\n *\n * @param {Function} callback\n */\nfunction registerLogger(callback) {\n    logger = callback;\n}\n\n/**\n * Send an alert message to the logger\n *\n * @param {String} message\n */\nfunction logAlert(message) {\n    logger({message: `[Onyx] ${message}`, level: 'alert'});\n}\n\n/**\n * Send an info message to the logger\n *\n * @param {String} message\n */\nfunction logInfo(message) {\n    logger({message: `[Onyx] ${message}`, level: 'info'});\n}\n\nexport {\n    registerLogger,\n    logInfo,\n    logAlert,\n};\n","import AsciTable from 'ascii-table';\n\nclass MDTable extends AsciTable {\n    /**\n     * Create a CSV string from the table data\n     * @returns {string}\n     */\n    toCSV() {\n        return [this.getTitle(), this.getHeading(), ...this.getRows()].join('\\n');\n    }\n\n    /**\n     * Create a JSON string from the table data\n     * @returns {string}\n     */\n    toJSON() {\n        return JSON.stringify(super.toJSON());\n    }\n\n    /**\n     * Create a MD string from the table data\n     * @returns {string}\n     */\n    toString() {\n        // Ignore modifying the first |---| for titled tables\n        let idx = this.getTitle() ? -2 : -1;\n        const ascii = super.toString()\n            .replace(/-\\|/g, () => {\n                /* we replace \"----|\" with \"---:|\" to align the data to the right in MD */\n                idx++;\n\n                if (idx < 0 || this.leftAlignedCols.includes(idx)) {\n                    return '-|';\n                }\n\n                return ':|';\n            });\n\n        // strip the top and the bottom row (----) to make an MD table\n        const md = ascii.split('\\n').slice(1, -1).join('\\n');\n        return md;\n    }\n}\n\n/**\n * Table Factory helper\n * @param {Object} options\n * @param {string} [options.title] - optional title center above the table\n * @param {string[]} options.heading - table column names\n * @param {number[]} [options.leftAlignedCols=[]] - indexes of columns that should be left aligned\n * Pass the columns that are non numeric here - the rest will be aligned to the right\n * @param {Array} [options.rows] The table can be initialized with row. Rows can also be added by `addRow`\n * @returns {MDTable}\n */\nMDTable.factory = ({\n    title, heading, leftAlignedCols = [], rows = []\n}) => {\n    const table = new MDTable({title, heading, rows});\n    table.leftAlignedCols = leftAlignedCols;\n\n    /* By default we want everything aligned to the right as most values are numbers\n         * we just override the columns that are not right aligned */\n    heading.forEach((name, idx) => table.setAlign(idx, AsciTable.RIGHT));\n    leftAlignedCols.forEach(idx => table.setAlign(idx, AsciTable.LEFT));\n\n    return table;\n};\n\nexport default MDTable;\n","import _ from 'underscore';\nimport Str from 'expensify-common/lib/str';\nimport lodashMerge from 'lodash/merge';\nimport Storage from './storage';\n\nimport {registerLogger, logInfo, logAlert} from './Logger';\nimport cache from './OnyxCache';\nimport createDeferredTask from './createDeferredTask';\n\n// Keeps track of the last connectionID that was used so we can keep incrementing it\nlet lastConnectionID = 0;\n\n// Holds a mapping of all the react components that want their state subscribed to a store key\nconst callbackToStateMapping = {};\n\n// Stores all of the keys that Onyx can use. Must be defined in init().\nlet onyxKeys = {};\n\n// Holds a list of keys that have been directly subscribed to or recently modified from least to most recent\nlet recentlyAccessedKeys = [];\n\n// Holds a list of keys that are safe to remove when we reach max storage. If a key does not match with\n// whatever appears in this list it will NEVER be a candidate for eviction.\nlet evictionAllowList = [];\n\n// Holds a map of keys and connectionID arrays whose keys will never be automatically evicted as\n// long as we have at least one subscriber that returns false for the canEvict property.\nconst evictionBlocklist = {};\n\n// Optional user-provided key value states set when Onyx initializes or clears\nlet defaultKeyStates = {};\n\n// Connections can be made before `Onyx.init`. They would wait for this task before resolving\nconst deferredInitTask = createDeferredTask();\n\n/**\n * Get some data from the store\n *\n * @private\n * @param {string} key\n * @returns {Promise<*>}\n */\nfunction get(key) {\n    // When we already have the value in cache - resolve right away\n    if (cache.hasCacheForKey(key)) {\n        return Promise.resolve(cache.getValue(key));\n    }\n\n    const taskName = `get:${key}`;\n\n    // When a value retrieving task for this key is still running hook to it\n    if (cache.hasPendingTask(taskName)) {\n        return cache.getTaskPromise(taskName);\n    }\n\n    // Otherwise retrieve the value from storage and capture a promise to aid concurrent usages\n    const promise = Storage.getItem(key)\n        .then((val) => {\n            cache.set(key, val);\n            return val;\n        })\n        .catch(err => logInfo(`Unable to get item from persistent storage. Key: ${key} Error: ${err}`));\n\n    return cache.captureTask(taskName, promise);\n}\n\n/**\n * Returns current key names stored in persisted storage\n * @private\n * @returns {Promise<string[]>}\n */\nfunction getAllKeys() {\n    // When we've already read stored keys, resolve right away\n    const storedKeys = cache.getAllKeys();\n    if (storedKeys.length > 0) {\n        return Promise.resolve(storedKeys);\n    }\n\n    const taskName = 'getAllKeys';\n\n    // When a value retrieving task for all keys is still running hook to it\n    if (cache.hasPendingTask(taskName)) {\n        return cache.getTaskPromise(taskName);\n    }\n\n    // Otherwise retrieve the keys from storage and capture a promise to aid concurrent usages\n    const promise = Storage.getAllKeys()\n        .then((keys) => {\n            _.each(keys, key => cache.addKey(key));\n            return keys;\n        });\n\n    return cache.captureTask(taskName, promise);\n}\n\n/**\n * Checks to see if the a subscriber's supplied key\n * is associated with a collection of keys.\n *\n * @private\n * @param {String} key\n * @returns {Boolean}\n */\nfunction isCollectionKey(key) {\n    return _.contains(_.values(onyxKeys.COLLECTION), key);\n}\n\n/**\n * Checks to see if a given key matches with the\n * configured key of our connected subscriber\n *\n * @private\n * @param {String} configKey\n * @param {String} key\n * @return {Boolean}\n */\nfunction isKeyMatch(configKey, key) {\n    return isCollectionKey(configKey)\n        ? Str.startsWith(key, configKey)\n        : configKey === key;\n}\n\n/**\n * Checks to see if this key has been flagged as\n * safe for removal.\n *\n * @private\n * @param {String} testKey\n * @returns {Boolean}\n */\nfunction isSafeEvictionKey(testKey) {\n    return _.some(evictionAllowList, key => isKeyMatch(key, testKey));\n}\n\n/**\n * Remove a key from the recently accessed key list.\n *\n * @private\n * @param {String} key\n */\nfunction removeLastAccessedKey(key) {\n    recentlyAccessedKeys = _.without(recentlyAccessedKeys, key);\n}\n\n/**\n * Add a key to the list of recently accessed keys. The least\n * recently accessed key should be at the head and the most\n * recently accessed key at the tail.\n *\n * @private\n * @param {String} key\n */\nfunction addLastAccessedKey(key) {\n    // Only specific keys belong in this list since we cannot remove an entire collection.\n    if (isCollectionKey(key) || !isSafeEvictionKey(key)) {\n        return;\n    }\n\n    removeLastAccessedKey(key);\n    recentlyAccessedKeys.push(key);\n}\n\n/**\n * Removes a key previously added to this list\n * which will enable it to be deleted again.\n *\n * @private\n * @param {String} key\n * @param {Number} connectionID\n */\nfunction removeFromEvictionBlockList(key, connectionID) {\n    evictionBlocklist[key] = _.without(evictionBlocklist[key] || [], connectionID);\n\n    // Remove the key if there are no more subscribers\n    if (evictionBlocklist[key].length === 0) {\n        delete evictionBlocklist[key];\n    }\n}\n\n/**\n * Keys added to this list can never be deleted.\n *\n * @private\n * @param {String} key\n * @param {Number} connectionID\n */\nfunction addToEvictionBlockList(key, connectionID) {\n    removeFromEvictionBlockList(key, connectionID);\n\n    if (!evictionBlocklist[key]) {\n        evictionBlocklist[key] = [];\n    }\n\n    evictionBlocklist[key].push(connectionID);\n}\n\n/**\n * Take all the keys that are safe to evict and add them to\n * the recently accessed list when initializing the app. This\n * enables keys that have not recently been accessed to be\n * removed.\n *\n * @private\n * @returns {Promise}\n */\nfunction addAllSafeEvictionKeysToRecentlyAccessedList() {\n    return getAllKeys()\n        .then((keys) => {\n            _.each(evictionAllowList, (safeEvictionKey) => {\n                _.each(keys, (key) => {\n                    if (isKeyMatch(safeEvictionKey, key)) {\n                        addLastAccessedKey(key);\n                    }\n                });\n            });\n        });\n}\n\n/**\n * @private\n * @param {String} collectionKey\n * @returns {Object}\n */\nfunction getCachedCollection(collectionKey) {\n    const collectionMemberKeys = _.filter(cache.getAllKeys(), (\n        storedKey => isKeyMatch(collectionKey, storedKey)\n    ));\n\n    return _.reduce(collectionMemberKeys, (prev, curr) => {\n        const cachedValue = cache.getValue(curr);\n        if (!cachedValue) {\n            return prev;\n        }\n        return ({\n            ...prev,\n            [curr]: cachedValue,\n        });\n    }, {});\n}\n\n/**\n * When a collection of keys change, search for any callbacks matching the collection key and trigger those callbacks\n *\n * @private\n * @param {String} collectionKey\n * @param {Object} collection\n */\nfunction keysChanged(collectionKey, collection) {\n    // Find all subscribers that were added with connect() and trigger the callback or setState() with the new data\n    _.each(callbackToStateMapping, (subscriber) => {\n        if (!subscriber) {\n            return;\n        }\n\n        const isSubscribedToCollectionKey = isKeyMatch(subscriber.key, collectionKey)\n            && isCollectionKey(subscriber.key);\n        const isSubscribedToCollectionMemberKey = subscriber.key.startsWith(collectionKey);\n\n        if (isSubscribedToCollectionKey) {\n            if (_.isFunction(subscriber.callback)) {\n                // eslint-disable-next-line no-use-before-define\n                const cachedCollection = getCachedCollection(collectionKey);\n                _.each(collection, (data, dataKey) => {\n                    subscriber.callback(cachedCollection[dataKey], dataKey);\n                });\n            } else if (subscriber.withOnyxInstance) {\n                subscriber.withOnyxInstance.setState((prevState) => {\n                    const finalCollection = _.clone(prevState[subscriber.statePropertyName] || {});\n                    _.each(collection, (data, dataKey) => {\n                        if (finalCollection[dataKey]) {\n                            lodashMerge(finalCollection[dataKey], data);\n                        } else {\n                            finalCollection[dataKey] = data;\n                        }\n                    });\n\n                    return {\n                        [subscriber.statePropertyName]: finalCollection,\n                    };\n                });\n            }\n        } else if (isSubscribedToCollectionMemberKey) {\n            const dataFromCollection = collection[subscriber.key];\n\n            // If `dataFromCollection` happens to not exist, then return early so that there are no unnecessary\n            // re-renderings of the component\n            if (_.isUndefined(dataFromCollection)) {\n                return;\n            }\n\n            subscriber.withOnyxInstance.setState(prevState => ({\n                [subscriber.statePropertyName]: _.isObject(dataFromCollection)\n                    ? {\n                        ...prevState[subscriber.statePropertyName],\n                        ...dataFromCollection,\n                    }\n                    : dataFromCollection,\n            }));\n        }\n    });\n}\n\n/**\n * When a key change happens, search for any callbacks matching the key or collection key and trigger those callbacks\n *\n * @private\n * @param {String} key\n * @param {*} data\n */\nfunction keyChanged(key, data) {\n    // Add or remove this key from the recentlyAccessedKeys lists\n    if (!_.isNull(data)) {\n        addLastAccessedKey(key);\n    } else {\n        removeLastAccessedKey(key);\n    }\n\n    // Find all subscribers that were added with connect() and trigger the callback or setState() with the new data\n    _.each(callbackToStateMapping, (subscriber) => {\n        if (subscriber && isKeyMatch(subscriber.key, key)) {\n            if (_.isFunction(subscriber.callback)) {\n                subscriber.callback(data, key);\n            }\n\n            if (!subscriber.withOnyxInstance) {\n                return;\n            }\n\n            // Check if we are subscribing to a collection key and add this item as a collection\n            if (isCollectionKey(subscriber.key)) {\n                subscriber.withOnyxInstance.setState((prevState) => {\n                    const collection = _.clone(prevState[subscriber.statePropertyName] || {});\n                    collection[key] = data;\n                    return {\n                        [subscriber.statePropertyName]: collection,\n                    };\n                });\n            } else {\n                subscriber.withOnyxInstance.setState({\n                    [subscriber.statePropertyName]: data,\n                });\n            }\n        }\n    });\n}\n\n/**\n * Sends the data obtained from the keys to the connection. It either:\n *     - sets state on the withOnyxInstances\n *     - triggers the callback function\n *\n * @private\n * @param {object} config\n * @param {object} [config.withOnyxInstance]\n * @param {string} [config.statePropertyName]\n * @param {function} [config.callback]\n * @param {*|null} val\n * @param {String} key\n */\nfunction sendDataToConnection(config, val, key) {\n    // If the mapping no longer exists then we should not send any data.\n    // This means our subscriber disconnected or withOnyx wrapped component unmounted.\n    if (!callbackToStateMapping[config.connectionID]) {\n        return;\n    }\n\n    if (config.withOnyxInstance) {\n        config.withOnyxInstance.setWithOnyxState(config.statePropertyName, val);\n    } else if (_.isFunction(config.callback)) {\n        config.callback(val, key);\n    }\n}\n\n/**\n * Subscribes a react component's state directly to a store key\n *\n * @example\n * const connectionID = Onyx.connect({\n *     key: ONYXKEYS.SESSION,\n *     callback: onSessionChange,\n * });\n *\n * @param {Object} mapping the mapping information to connect Onyx to the components state\n * @param {String} mapping.key ONYXKEY to subscribe to\n * @param {String} [mapping.statePropertyName] the name of the property in the state to connect the data to\n * @param {Object} [mapping.withOnyxInstance] whose setState() method will be called with any changed data\n *      This is used by React components to connect to Onyx\n * @param {Function} [mapping.callback] a method that will be called with changed data\n *      This is used by any non-React code to connect to Onyx\n * @param {Boolean} [mapping.initWithStoredValues] If set to false, then no data will be prefilled into the\n *  component\n * @returns {Number} an ID to use when calling disconnect\n */\nfunction connect(mapping) {\n    const connectionID = lastConnectionID++;\n    callbackToStateMapping[connectionID] = mapping;\n    callbackToStateMapping[connectionID].connectionID = connectionID;\n\n    if (mapping.initWithStoredValues === false) {\n        return connectionID;\n    }\n\n    // Commit connection only after init passes\n    deferredInitTask.promise\n        .then(() => {\n            // Check to see if this key is flagged as a safe eviction key and add it to the recentlyAccessedKeys list\n            if (isSafeEvictionKey(mapping.key)) {\n                // Try to free some cache whenever we connect to a safe eviction key\n                cache.removeLeastRecentlyUsedKeys();\n\n                if (mapping.withOnyxInstance && !isCollectionKey(mapping.key)) {\n                    // All React components subscribing to a key flagged as a safe eviction\n                    // key must implement the canEvict property.\n                    if (_.isUndefined(mapping.canEvict)) {\n                        throw new Error(\n                            `Cannot subscribe to safe eviction key '${mapping.key}' without providing a canEvict value.`\n                        );\n                    }\n\n                    addLastAccessedKey(mapping.key);\n                }\n            }\n        })\n        .then(getAllKeys)\n        .then((keys) => {\n            // Find all the keys matched by the config key\n            const matchingKeys = _.filter(keys, key => isKeyMatch(mapping.key, key));\n\n            // If the key being connected to does not exist, initialize the value with null\n            if (matchingKeys.length === 0) {\n                sendDataToConnection(mapping, null);\n                return;\n            }\n\n            // When using a callback subscriber we will trigger the callback\n            // for each key we find. It's up to the subscriber to know whether\n            // to expect a single key or multiple keys in the case of a collection.\n            // React components are an exception since we'll want to send their\n            // initial data as a single object when using collection keys.\n            if (mapping.withOnyxInstance && isCollectionKey(mapping.key)) {\n                Promise.all(_.map(matchingKeys, key => get(key)))\n                    .then(values => _.reduce(values, (finalObject, value, i) => ({\n                        ...finalObject,\n                        [matchingKeys[i]]: value,\n                    }), {}))\n                    .then(val => sendDataToConnection(mapping, val));\n            } else {\n                _.each(matchingKeys, (key) => {\n                    get(key).then(val => sendDataToConnection(mapping, val, key));\n                });\n            }\n        });\n\n    return connectionID;\n}\n\n/**\n * Remove the listener for a react component\n * @example\n * Onyx.disconnect(connectionID);\n *\n * @param {Number} connectionID unique id returned by call to Onyx.connect()\n * @param {String} [keyToRemoveFromEvictionBlocklist]\n */\nfunction disconnect(connectionID, keyToRemoveFromEvictionBlocklist) {\n    if (!callbackToStateMapping[connectionID]) {\n        return;\n    }\n\n    // Remove this key from the eviction block list as we are no longer\n    // subscribing to it and it should be safe to delete again\n    if (keyToRemoveFromEvictionBlocklist) {\n        removeFromEvictionBlockList(keyToRemoveFromEvictionBlocklist, connectionID);\n    }\n\n    delete callbackToStateMapping[connectionID];\n}\n\n/**\n * Remove a key from Onyx and update the subscribers\n *\n * @private\n * @param {String} key\n * @return {Promise}\n */\nfunction remove(key) {\n    // Cache the fact that the value was removed\n    cache.set(key, null);\n\n    // Optimistically inform subscribers on the next tick\n    Promise.resolve().then(() => keyChanged(key, null));\n\n    return Storage.removeItem(key);\n}\n\n/**\n * If we fail to set or merge we must handle this by\n * evicting some data from Onyx and then retrying to do\n * whatever it is we attempted to do.\n *\n * @private\n * @param {Error} error\n * @param {Function} onyxMethod\n * @param  {...any} args\n * @return {Promise}\n */\nfunction evictStorageAndRetry(error, onyxMethod, ...args) {\n    logInfo(`Handled error: ${error}`);\n\n    if (error && Str.startsWith(error.message, 'Failed to execute \\'put\\' on \\'IDBObjectStore\\'')) {\n        logAlert('Attempted to set invalid data set in Onyx. Please ensure all data is serializable.');\n        throw error;\n    }\n\n    // Find the first key that we can remove that has no subscribers in our blocklist\n    const keyForRemoval = _.find(recentlyAccessedKeys, key => !evictionBlocklist[key]);\n\n    if (!keyForRemoval) {\n        logAlert('Out of storage. But found no acceptable keys to remove.');\n        throw error;\n    }\n\n    // Remove the least recently viewed key that is not currently being accessed and retry.\n    logInfo(`Out of storage. Evicting least recently accessed key (${keyForRemoval}) and retrying.`);\n    return remove(keyForRemoval)\n        .then(() => onyxMethod(...args));\n}\n\n/**\n * Write a value to our store with the given key\n *\n * @param {String} key ONYXKEY to set\n * @param {*} value value to store\n *\n * @returns {Promise}\n */\nfunction set(key, value) {\n    // Logging properties only since values could be sensitive things we don't want to log\n    logInfo(`set() called for key: ${key}${_.isObject(value) ? ` properties: ${_.keys(value).join(',')}` : ''}`);\n\n    // eslint-disable-next-line no-use-before-define\n    if (hasPendingMergeForKey(key)) {\n        // eslint-disable-next-line max-len\n        logAlert(`Onyx.set() called after Onyx.merge() for key: ${key}. It is recommended to use set() or merge() not both.`);\n    }\n\n    // Adds the key to cache when it's not available\n    cache.set(key, value);\n\n    // Optimistically inform subscribers on the next tick\n    Promise.resolve().then(() => keyChanged(key, value));\n\n    // Write the thing to persistent storage, which will trigger a storage event for any other tabs open on this domain\n    return Storage.setItem(key, value)\n        .catch(error => evictStorageAndRetry(error, set, key, value));\n}\n\n/**\n * Storage expects array like: [[\"@MyApp_user\", value_1], [\"@MyApp_key\", value_2]]\n * This method transforms an object like {'@MyApp_user': myUserValue, '@MyApp_key': myKeyValue}\n * to an array of key-value pairs in the above format\n * @private\n * @param {Record} data\n * @return {Array} an array of key - value pairs <[key, value]>\n */\nfunction prepareKeyValuePairsForStorage(data) {\n    return _.map(data, (value, key) => [key, value]);\n}\n\n/**\n * Sets multiple keys and values\n *\n * @example Onyx.multiSet({'key1': 'a', 'key2': 'b'});\n *\n * @param {Object} data object keyed by ONYXKEYS and the values to set\n * @returns {Promise}\n */\nfunction multiSet(data) {\n    const keyValuePairs = prepareKeyValuePairsForStorage(data);\n\n    _.each(data, (val, key) => {\n        // Update cache and optimistically inform subscribers on the next tick\n        cache.set(key, val);\n        Promise.resolve().then(() => keyChanged(key, val));\n    });\n\n    return Storage.multiSet(keyValuePairs)\n        .catch(error => evictStorageAndRetry(error, multiSet, data));\n}\n\n// Key/value store of Onyx key and arrays of values to merge\nconst mergeQueue = {};\n\n/**\n * @private\n * @param {String} key\n * @returns {Boolean}\n */\nfunction hasPendingMergeForKey(key) {\n    return Boolean(mergeQueue[key]);\n}\n\n/**\n * Given an Onyx key and value this method will combine all queued\n * value updates and return a single value. Merge attempts are\n * batched. They must occur after a single call to get() so we\n * can avoid race conditions.\n *\n * @private\n * @param {String} key\n * @param {*} data\n *\n * @returns {*}\n */\nfunction applyMerge(key, data) {\n    const mergeValues = mergeQueue[key];\n    if (_.isArray(data) || _.every(mergeValues, _.isArray)) {\n        // Array values will always just concatenate\n        // more items onto the end of the array\n        return _.reduce(mergeValues, (modifiedData, mergeValue) => [\n            ...modifiedData,\n            ...mergeValue,\n        ], data || []);\n    }\n\n    if (_.isObject(data) || _.every(mergeValues, _.isObject)) {\n        // Object values are merged one after the other\n        return _.reduce(mergeValues, (modifiedData, mergeValue) => {\n            const newData = lodashMerge({}, modifiedData, mergeValue);\n\n            // We will also delete any object keys that are undefined or null.\n            // Deleting keys is not supported by AsyncStorage so we do it this way.\n            // Remove all first level keys that are explicitly set to null.\n            return _.omit(newData, (value, finalObjectKey) => _.isNull(mergeValue[finalObjectKey]));\n        }, data || {});\n    }\n\n    // If we have anything else we can't merge it so we'll\n    // simply return the last value that was queued\n    return _.last(mergeValues);\n}\n\n/**\n * Merge a new value into an existing value at a key.\n *\n * The types of values that can be merged are `Object` and `Array`. To set another type of value use `Onyx.set()`. Merge\n * behavior uses lodash/merge under the hood for `Object` and simple concatenation for `Array`. However, it's important\n * to note that if you have an array value property on an `Object` that the default behavior of lodash/merge is not to\n * concatenate. See here: https://github.com/lodash/lodash/issues/2872\n *\n * Calls to `Onyx.merge()` are batched so that any calls performed in a single tick will stack in a queue and get\n * applied in the order they were called. Note: `Onyx.set()` calls do not work this way so use caution when mixing\n * `Onyx.merge()` and `Onyx.set()`.\n *\n * @example\n * Onyx.merge(ONYXKEYS.EMPLOYEE_LIST, ['Joe']); // -> ['Joe']\n * Onyx.merge(ONYXKEYS.EMPLOYEE_LIST, ['Jack']); // -> ['Joe', 'Jack']\n * Onyx.merge(ONYXKEYS.POLICY, {id: 1}); // -> {id: 1}\n * Onyx.merge(ONYXKEYS.POLICY, {name: 'My Workspace'}); // -> {id: 1, name: 'My Workspace'}\n *\n * @param {String} key ONYXKEYS key\n * @param {(Object|Array)} value Object or Array value to merge\n * @returns {Promise}\n */\nfunction merge(key, value) {\n    if (mergeQueue[key]) {\n        mergeQueue[key].push(value);\n        return Promise.resolve();\n    }\n\n    mergeQueue[key] = [value];\n    return get(key)\n        .then((data) => {\n            try {\n                const modifiedData = applyMerge(key, data);\n\n                // Clean up the write queue so we\n                // don't apply these changes again\n                delete mergeQueue[key];\n\n                return set(key, modifiedData);\n            } catch (error) {\n                logAlert(`An error occurred while applying merge for key: ${key}, Error: ${error}`);\n            }\n\n            return Promise.resolve();\n        });\n}\n\n/**\n * Merge user provided default key value pairs.\n * @private\n * @returns {Promise}\n */\nfunction initializeWithDefaultKeyStates() {\n    return Storage.multiGet(_.keys(defaultKeyStates))\n        .then((pairs) => {\n            const asObject = _.object(pairs);\n\n            const merged = lodashMerge(asObject, defaultKeyStates);\n            cache.merge(merged);\n            _.each(merged, (val, key) => keyChanged(key, val));\n        });\n}\n\n/**\n * Clear out all the data in the store\n *\n * @returns {Promise<void>}\n */\nfunction clear() {\n    return getAllKeys()\n        .then((keys) => {\n            _.each(keys, (key) => {\n                keyChanged(key, null);\n                cache.set(key, null);\n            });\n        })\n        .then(Storage.clear)\n        .then(initializeWithDefaultKeyStates);\n}\n\n/**\n * Merges a collection based on their keys\n *\n * @example\n *\n * Onyx.mergeCollection(ONYXKEYS.COLLECTION.REPORT, {\n *     [`${ONYXKEYS.COLLECTION.REPORT}1`]: report1,\n *     [`${ONYXKEYS.COLLECTION.REPORT}2`]: report2,\n * });\n *\n * @param {String} collectionKey e.g. `ONYXKEYS.COLLECTION.REPORT`\n * @param {Object} collection Object collection keyed by individual collection member keys and values\n * @returns {Promise}\n */\nfunction mergeCollection(collectionKey, collection) {\n    // Confirm all the collection keys belong to the same parent\n    _.each(collection, (data, dataKey) => {\n        if (!isKeyMatch(collectionKey, dataKey)) {\n            // eslint-disable-next-line max-len\n            throw new Error(`Provided collection does not have all its data belonging to the same parent. CollectionKey: ${collectionKey}, DataKey: ${dataKey}`);\n        }\n    });\n\n    return getAllKeys()\n        .then((persistedKeys) => {\n            // Split to keys that exist in storage and keys that don't\n            const [existingKeys, newKeys] = _.chain(collection)\n                .keys()\n                .partition(key => persistedKeys.includes(key))\n                .value();\n\n            const existingKeyCollection = _.pick(collection, existingKeys);\n            const newCollection = _.pick(collection, newKeys);\n            const keyValuePairsForExistingCollection = prepareKeyValuePairsForStorage(existingKeyCollection);\n            const keyValuePairsForNewCollection = prepareKeyValuePairsForStorage(newCollection);\n\n            const promises = [];\n\n            // New keys will be added via multiSet while existing keys will be updated using multiMerge\n            // This is because setting a key that doesn't exist yet with multiMerge will throw errors\n            if (keyValuePairsForExistingCollection.length > 0) {\n                promises.push(Storage.multiMerge(keyValuePairsForExistingCollection));\n            }\n\n            if (keyValuePairsForNewCollection.length > 0) {\n                promises.push(Storage.multiSet(keyValuePairsForNewCollection));\n            }\n\n            // Prefill cache if necessary by calling get() on any existing keys and then merge original data to cache\n            // and update all subscribers\n            Promise.all(_.map(existingKeys, get)).then(() => {\n                cache.merge(collection);\n                keysChanged(collectionKey, collection);\n            });\n\n            return Promise.all(promises)\n                .catch(error => evictStorageAndRetry(error, mergeCollection, collection));\n        });\n}\n\n/**\n * Initialize the store with actions and listening for storage events\n *\n * @param {Object} [options={}] config object\n * @param {Object} [options.keys={}] `ONYXKEYS` constants object\n * @param {Object} [options.initialKeyStates={}] initial data to set when `init()` and `clear()` is called\n * @param {String[]} [options.safeEvictionKeys=[]] This is an array of keys\n * (individual or collection patterns) that when provided to Onyx are flagged\n * as \"safe\" for removal. Any components subscribing to these keys must also\n * implement a canEvict option. See the README for more info.\n * @param {Number} [options.maxCachedKeysCount=55] Sets how many recent keys should we try to keep in cache\n * Setting this to 0 would practically mean no cache\n * We try to free cache when we connect to a safe eviction key\n * @param {Boolean} [options.captureMetrics] Enables Onyx benchmarking and exposes the get/print/reset functions\n * @param {Boolean} [options.shouldSyncMultipleInstances] Auto synchronize storage events between multiple instances\n * of Onyx running in different tabs/windows. Defaults to true for platforms that support local storage (web/desktop)\n * @param {String[]} [option.keysToDisableSyncEvents=[]] Contains keys for which\n * we want to disable sync event across tabs.\n * @example\n * Onyx.init({\n *     keys: ONYXKEYS,\n *     initialKeyStates: {\n *         [ONYXKEYS.SESSION]: {loading: false},\n *     },\n * });\n */\nfunction init({\n    keys = {},\n    initialKeyStates = {},\n    safeEvictionKeys = [],\n    maxCachedKeysCount = 1000,\n    captureMetrics = false,\n    shouldSyncMultipleInstances = Boolean(global.localStorage),\n    keysToDisableSyncEvents = [],\n} = {}) {\n    if (captureMetrics) {\n        // The code here is only bundled and applied when the captureMetrics is set\n        // eslint-disable-next-line no-use-before-define\n        applyDecorators();\n    }\n\n    if (maxCachedKeysCount > 0) {\n        cache.setRecentKeysLimit(maxCachedKeysCount);\n    }\n\n    // Let Onyx know about all of our keys\n    onyxKeys = keys;\n\n    // Set our default key states to use when initializing and clearing Onyx data\n    defaultKeyStates = initialKeyStates;\n\n    // Let Onyx know about which keys are safe to evict\n    evictionAllowList = safeEvictionKeys;\n\n    // Initialize all of our keys with data provided then give green light to any pending connections\n    Promise.all([\n        addAllSafeEvictionKeysToRecentlyAccessedList(),\n        initializeWithDefaultKeyStates()\n    ])\n        .then(deferredInitTask.resolve);\n\n    if (shouldSyncMultipleInstances && _.isFunction(Storage.keepInstancesSync)) {\n        Storage.keepInstancesSync(keysToDisableSyncEvents, (key, value) => {\n            cache.set(key, value);\n            keyChanged(key, value);\n        });\n    }\n}\n\nconst Onyx = {\n    connect,\n    disconnect,\n    set,\n    multiSet,\n    merge,\n    mergeCollection,\n    clear,\n    init,\n    registerLogger,\n    addToEvictionBlockList,\n    removeFromEvictionBlockList,\n    isSafeEvictionKey,\n};\n\n/**\n * Apply calls statistic decorators to benchmark Onyx\n *\n * @private\n */\nfunction applyDecorators() {\n    // We're requiring the script dynamically here so that it's only evaluated when decorators are used\n    const decorate = require('./metrics');\n\n    // Re-assign with decorated functions\n    /* eslint-disable no-func-assign */\n    get = decorate.decorateWithMetrics(get, 'Onyx:get');\n    set = decorate.decorateWithMetrics(set, 'Onyx:set');\n    multiSet = decorate.decorateWithMetrics(multiSet, 'Onyx:multiSet');\n    clear = decorate.decorateWithMetrics(clear, 'Onyx:clear');\n    merge = decorate.decorateWithMetrics(merge, 'Onyx:merge');\n    mergeCollection = decorate.decorateWithMetrics(mergeCollection, 'Onyx:mergeCollection');\n    getAllKeys = decorate.decorateWithMetrics(getAllKeys, 'Onyx:getAllKeys');\n    initializeWithDefaultKeyStates = decorate.decorateWithMetrics(initializeWithDefaultKeyStates, 'Onyx:defaults');\n    /* eslint-enable */\n\n    // Re-expose decorated methods\n    Onyx.set = set;\n    Onyx.multiSet = multiSet;\n    Onyx.clear = clear;\n    Onyx.merge = merge;\n    Onyx.mergeCollection = mergeCollection;\n\n    // Expose stats methods on Onyx\n    Onyx.getMetrics = decorate.getMetrics;\n    Onyx.resetMetrics = decorate.resetMetrics;\n    Onyx.printMetrics = decorate.printMetrics;\n}\n\nexport default Onyx;\n","import _ from 'underscore';\nimport lodashMerge from 'lodash/merge';\n\n\nconst isDefined = _.negate(_.isUndefined);\n\n/**\n * In memory cache providing data by reference\n * Encapsulates Onyx cache related functionality\n */\nclass OnyxCache {\n    constructor() {\n        /**\n         * @private\n         * Cache of all the storage keys available in persistent storage\n         * @type {Set<string>}\n         */\n        this.storageKeys = new Set();\n\n        /**\n         * @private\n         * Unique list of keys maintained in access order (most recent at the end)\n         * @type {Set<string>}\n         */\n        this.recentKeys = new Set();\n\n        /**\n         * @private\n         * A map of cached values\n         * @type {Record<string, *>}\n         */\n        this.storageMap = {};\n\n        /**\n         * @private\n         * Captured pending tasks for already running storage methods\n         * @type {Record<string, Promise>}\n         */\n        this.pendingPromises = {};\n\n        // bind all public methods to prevent problems with `this`\n        _.bindAll(\n            this,\n            'getAllKeys', 'getValue', 'hasCacheForKey', 'addKey', 'set', 'drop', 'merge',\n            'hasPendingTask', 'getTaskPromise', 'captureTask', 'removeLeastRecentlyUsedKeys',\n            'setRecentKeysLimit'\n        );\n    }\n\n    /**\n     * Get all the storage keys\n     * @returns {string[]}\n     */\n    getAllKeys() {\n        return Array.from(this.storageKeys);\n    }\n\n    /**\n     * Get a cached value from storage\n     * @param {string} key\n     * @returns {*}\n     */\n    getValue(key) {\n        this.addToAccessedKeys(key);\n        return this.storageMap[key];\n    }\n\n    /**\n     * Check whether cache has data for the given key\n     * @param {string} key\n     * @returns {boolean}\n     */\n    hasCacheForKey(key) {\n        return isDefined(this.storageMap[key]);\n    }\n\n    /**\n     * Saves a key in the storage keys list\n     * Serves to keep the result of `getAllKeys` up to date\n     * @param {string} key\n     */\n    addKey(key) {\n        this.storageKeys.add(key);\n    }\n\n    /**\n     * Set's a key value in cache\n     * Adds the key to the storage keys list as well\n     * @param {string} key\n     * @param {*} value\n     * @returns {*} value - returns the cache value\n     */\n    set(key, value) {\n        this.addKey(key);\n        this.addToAccessedKeys(key);\n        this.storageMap[key] = value;\n\n        return value;\n    }\n\n    /**\n     * Forget the cached value for the given key\n     * @param {string} key\n     */\n    drop(key) {\n        delete this.storageMap[key];\n    }\n\n    /**\n     * Deep merge data to cache, any non existing keys will be created\n     * @param {Record<string, *>} data - a map of (cache) key - values\n     */\n    merge(data) {\n        this.storageMap = lodashMerge({}, this.storageMap, data);\n\n        const storageKeys = this.getAllKeys();\n        const mergedKeys = _.keys(data);\n        this.storageKeys = new Set([...storageKeys, ...mergedKeys]);\n        _.each(mergedKeys, key => this.addToAccessedKeys(key));\n    }\n\n    /**\n     * Check whether the given task is already running\n     * @param {string} taskName - unique name given for the task\n     * @returns {*}\n     */\n    hasPendingTask(taskName) {\n        return isDefined(this.pendingPromises[taskName]);\n    }\n\n    /**\n     * Use this method to prevent concurrent calls for the same thing\n     * Instead of calling the same task again use the existing promise\n     * provided from this function\n     * @template T\n     * @param {string} taskName - unique name given for the task\n     * @returns {Promise<T>}\n     */\n    getTaskPromise(taskName) {\n        return this.pendingPromises[taskName];\n    }\n\n    /**\n     * Capture a promise for a given task so other caller can\n     * hook up to the promise if it's still pending\n     * @template T\n     * @param {string} taskName - unique name for the task\n     * @param {Promise<T>} promise\n     * @returns {Promise<T>}\n     */\n    captureTask(taskName, promise) {\n        this.pendingPromises[taskName] = promise.finally(() => {\n            delete this.pendingPromises[taskName];\n        });\n\n        return this.pendingPromises[taskName];\n    }\n\n    /**\n     * @private\n     * Adds a key to the top of the recently accessed keys\n     * @param {string} key\n     */\n    addToAccessedKeys(key) {\n        // Removing and re-adding a key ensures it's at the end of the list\n        this.recentKeys.delete(key);\n        this.recentKeys.add(key);\n    }\n\n    /**\n     * Remove keys that don't fall into the range of recently used keys\n     */\n    removeLeastRecentlyUsedKeys() {\n        if (this.recentKeys.size > this.maxRecentKeysSize) {\n            // Get the last N keys by doing a negative slice\n            const recentlyAccessed = [...this.recentKeys].slice(-this.maxRecentKeysSize);\n            const storageKeys = _.keys(this.storageMap);\n            const keysToRemove = _.difference(storageKeys, recentlyAccessed);\n\n            _.each(keysToRemove, this.drop);\n        }\n    }\n\n    /**\n     * Set the recent keys list size\n     * @param {number} limit\n     */\n    setRecentKeysLimit(limit) {\n        this.maxRecentKeysSize = limit;\n    }\n}\n\nconst instance = new OnyxCache();\n\nexport default instance;\n","/**\n * Synchronous queue that can be used to ensure promise based tasks are run in sequence.\n * Pass to the constructor a function that returns a promise to run the task then add data.\n *\n * @example\n *\n *     const queue = new SyncQueue(({key, val}) => {\n *         return someAsyncProcess(key, val);\n *     });\n *\n *     queue.push({key: 1, val: '1'});\n *     queue.push({key: 2, val: '2'});\n */\nexport default class SyncQueue {\n    /**\n     * @param {Function} run - must return a promise\n     */\n    constructor(run) {\n        this.queue = [];\n        this.isProcessing = false;\n        this.run = run;\n    }\n\n    process() {\n        if (this.isProcessing || this.queue.length === 0) {\n            return;\n        }\n\n        this.isProcessing = true;\n\n        const {data, resolve, reject} = this.queue.shift();\n        this.run(data)\n            .then(resolve)\n            .catch(reject)\n            .finally(() => {\n                this.isProcessing = false;\n                this.process();\n            });\n    }\n\n    /**\n     * @param {*} data\n     * @returns {Promise}\n     */\n    push(data) {\n        return new Promise((resolve, reject) => {\n            this.queue.push({resolve, reject, data});\n            this.process();\n        });\n    }\n}\n","/**\n * Create a deferred task that can be resolved when we call `resolve()`\n * The returned promise will complete when we call `resolve`\n * Useful when we want to wait for a tasks that is resolved from an external action\n *\n * @template T\n * @returns {{ resolve: function(*), promise: Promise<T|void> }}\n */\nexport default function createDeferredTask() {\n    const deferred = {};\n    deferred.promise = new Promise((res) => {\n        deferred.resolve = res;\n    });\n\n    return deferred;\n}\n","import _ from 'underscore';\nimport performance from 'react-native-performance';\nimport MDTable from '../MDTable';\n\nconst decoratedAliases = new Set();\n\n/**\n * Capture a start mark to performance entries\n * @param {string} alias\n * @param {Array<*>} args\n * @returns {{name: string, startTime:number, detail: {args: [], alias: string}}}\n */\nfunction addMark(alias, args) {\n    return performance.mark(alias, {detail: {args, alias}});\n}\n\n/**\n * Capture a measurement between the start mark and now\n * @param {{name: string, startTime:number, detail: {args: []}}} startMark\n * @param {*} detail\n */\nfunction measureMarkToNow(startMark, detail) {\n    performance.measure(`${startMark.name} [${startMark.detail.args.toString()}]`, {\n        start: startMark.startTime,\n        end: performance.now(),\n        detail: {...startMark.detail, ...detail}\n    });\n}\n\n/**\n * Wraps a function with metrics capturing logic\n * @param {function} func\n * @param {String} [alias]\n * @returns {function} The wrapped function\n */\nfunction decorateWithMetrics(func, alias = func.name) {\n    if (decoratedAliases.has(alias)) {\n        throw new Error(`\"${alias}\" is already decorated`);\n    }\n\n    decoratedAliases.add(alias);\n\n    function decorated(...args) {\n        const mark = addMark(alias, args);\n\n        const originalPromise = func.apply(this, args);\n\n        /*\n        * Then handlers added here are not affecting the original promise\n        * They create a separate chain that's not exposed (returned) to the original caller\n        * */\n        originalPromise\n            .then((result) => {\n                measureMarkToNow(mark, {result});\n            })\n            .catch((error) => {\n                measureMarkToNow(mark, {error});\n            });\n\n        return originalPromise;\n    }\n\n    return decorated;\n}\n\n/**\n * Calculate the total sum of a given key in a list\n * @param {Array<Record<prop, Number>>} list\n * @param {string} prop\n * @returns {number}\n */\nfunction sum(list, prop) {\n    return _.reduce(list, (memo, next) => memo + next[prop], 0);\n}\n\n/**\n * Aggregates and returns benchmark information\n * @returns {{summaries: Record<string, Object>, totalTime: number, lastCompleteCall: *}}\n * An object with\n * - `totalTime` - total time spent by decorated methods\n * - `lastCompleteCall` - millisecond since launch the last call completed at\n * - `summaries` - mapping of all captured stats: summaries.methodName -> method stats\n */\nfunction getMetrics() {\n    const summaries = _.chain(performance.getEntriesByType('measure'))\n        .filter(entry => entry.detail && decoratedAliases.has(entry.detail.alias))\n        .groupBy(entry => entry.detail.alias)\n        .map((calls, methodName) => {\n            const total = sum(calls, 'duration');\n            const avg = (total / calls.length) || 0;\n            const max = _.max(calls, 'duration').duration || 0;\n            const min = _.min(calls, 'duration').duration || 0;\n\n            // Latest complete call (by end time) for all the calls made to the current method\n            const lastCall = _.max(calls, call => call.startTime + call.duration);\n\n            return [methodName, {\n                methodName,\n                total,\n                max,\n                min,\n                avg,\n                lastCall,\n                calls,\n            }];\n        })\n        .object() // Create a map like methodName -> StatSummary\n        .value();\n\n    const totalTime = sum(_.values(summaries), 'total');\n\n    // Latest complete call (by end time) of all methods up to this point\n    const lastCompleteCall = _.max(\n        _.values(summaries),\n        summary => summary.lastCall.startTime + summary.lastCall.duration,\n    ).lastCall;\n\n    return {\n        totalTime,\n        summaries,\n        lastCompleteCall,\n    };\n}\n\n/**\n * Convert milliseconds to human readable time\n * @param {number} millis\n * @param {boolean} [raw=false]\n * @returns {string|number}\n */\nfunction toDuration(millis, raw = false) {\n    if (raw) {\n        return millis;\n    }\n\n    const minute = 60 * 1000;\n    if (millis > minute) {\n        return `${(millis / minute).toFixed(1)}min`;\n    }\n\n    const second = 1000;\n    if (millis > second) {\n        return `${(millis / second).toFixed(2)}sec`;\n    }\n\n    return `${millis.toFixed(3)}ms`;\n}\n\n/**\n * Print extensive information on the dev console\n * max, min, average, total time for each method\n * and a table of individual calls\n *\n * @param {Object} [options]\n * @param {boolean} [options.raw=false] - setting this to true will print raw instead of human friendly times\n * Useful when you copy the printed table to excel and let excel do the number formatting\n * @param {'console'|'csv'|'json'|'string'} [options.format=console] The output format of this function\n * `string` is useful when __DEV__ is set to `false` as writing to the console is disabled, but the result of this\n * method would still get printed as output\n * @param {string[]} [options.methods] Print stats only for these method names\n * @returns {string|undefined}\n */\nfunction printMetrics({raw = false, format = 'console', methods} = {}) {\n    const {totalTime, summaries, lastCompleteCall} = getMetrics();\n\n    const tableSummary = MDTable.factory({\n        heading: ['method', 'total time spent', 'max', 'min', 'avg', 'time last call completed', 'calls made'],\n        leftAlignedCols: [0],\n    });\n\n    /* Performance marks (startTimes) are relative to system uptime\n     * timeOrigin is the point at which the app started to init\n     * We use timeOrigin to display times relative to app launch time\n     * See: https://github.com/oblador/react-native-performance/issues/50 */\n    const timeOrigin = performance.timeOrigin;\n    const methodNames = _.isArray(methods) ? methods : _.keys(summaries);\n\n    const methodCallTables = _.chain(methodNames)\n        .filter(methodName => summaries[methodName] && summaries[methodName].avg > 0)\n        .map((methodName) => {\n            const {calls, ...methodStats} = summaries[methodName];\n            tableSummary.addRow(\n                methodName,\n                toDuration(methodStats.total, raw),\n                toDuration(methodStats.max, raw),\n                toDuration(methodStats.min, raw),\n                toDuration(methodStats.avg, raw),\n                toDuration((methodStats.lastCall.startTime + methodStats.lastCall.duration) - timeOrigin, raw),\n                calls.length,\n            );\n\n            return MDTable.factory({\n                title: methodName,\n                heading: ['start time', 'end time', 'duration', 'args'],\n                leftAlignedCols: [3],\n                rows: calls.map(call => ([\n                    toDuration(call.startTime - performance.timeOrigin, raw),\n                    toDuration((call.startTime + call.duration) - timeOrigin, raw),\n                    toDuration(call.duration, raw),\n                    call.detail.args.map(String).join(', ').slice(0, 60), // Restrict cell width to 60 chars max\n                ]))\n            });\n        })\n        .value();\n\n    if (/csv|json|string/i.test(format)) {\n        const allTables = [tableSummary, ...methodCallTables];\n\n        return allTables.map((table) => {\n            switch (format.toLowerCase()) {\n                case 'csv':\n                    return table.toCSV();\n                case 'json':\n                    return table.toJSON();\n                default:\n                    return table.toString();\n            }\n        }).join('\\n\\n');\n    }\n\n    const lastComplete = lastCompleteCall && toDuration(\n        (lastCompleteCall.startTime + lastCompleteCall.duration) - timeOrigin, raw\n    );\n\n    const mainOutput = [\n        '### Onyx Benchmark',\n        `  - Total: ${toDuration(totalTime, raw)}`,\n        `  - Last call finished at: ${lastComplete || 'N/A'}`,\n        '',\n        tableSummary.toString()\n    ];\n\n    /* eslint-disable no-console */\n    console.info(mainOutput.join('\\n'));\n    methodCallTables.forEach((table) => {\n        console.groupCollapsed(table.getTitle());\n        console.info(table.toString());\n        console.groupEnd();\n    });\n    /* eslint-enable */\n}\n\n/**\n * Clears all collected metrics.\n */\nfunction resetMetrics() {\n    const {summaries} = getMetrics();\n\n    _.chain(summaries)\n        .map(summary => summary.calls)\n        .flatten()\n        .each((measure) => {\n            performance.clearMarks(measure.detail.alias);\n            performance.clearMeasures(measure.name);\n        });\n}\n\nexport {\n    decorateWithMetrics,\n    getMetrics,\n    resetMetrics,\n    printMetrics,\n};\n","import Storage from './providers/AsyncStorage';\n\nexport default Storage;\n","import _ from 'underscore';\nimport Storage from './providers/LocalForage';\n\nconst SYNC_ONYX = 'SYNC_ONYX';\n\n/**\n * Raise an event thorough `localStorage` to let other tabs know a value changed\n * @param {String} onyxKey\n */\nfunction raiseStorageSyncEvent(onyxKey) {\n    global.localStorage.setItem(SYNC_ONYX, onyxKey);\n    global.localStorage.removeItem(SYNC_ONYX, onyxKey);\n}\n\nconst webStorage = {\n    ...Storage,\n\n    /**\n     * Contains keys for which we want to disable sync event across tabs.\n     * @param {String[]} keysToDisableSyncEvents\n     * Storage synchronization mechanism keeping all opened tabs in sync\n     * @param {function(key: String, data: *)} onStorageKeyChanged\n     */\n    keepInstancesSync(keysToDisableSyncEvents, onStorageKeyChanged) {\n        // Override set, remove and clear to raise storage events that we intercept in other tabs\n        this.setItem = (key, value) => Storage.setItem(key, value)\n            .then(() => raiseStorageSyncEvent(key));\n\n        this.removeItem = key => Storage.removeItem(key)\n            .then(() => raiseStorageSyncEvent(key));\n\n        // If we just call Storage.clear other tabs will have no idea which keys were available previously\n        // so that they can call keysChanged for them. That's why we iterate and remove keys one by one\n        this.clear = () => Storage.getAllKeys()\n            .then(keys => _.map(keys, key => this.removeItem(key)))\n            .then(tasks => Promise.all(tasks));\n\n        // This listener will only be triggered by events coming from other tabs\n        global.addEventListener('storage', (event) => {\n            // Ignore events that don't originate from the SYNC_ONYX logic\n            if (event.key !== SYNC_ONYX || !event.newValue) {\n                return;\n            }\n\n            const onyxKey = event.newValue;\n            if (_.contains(keysToDisableSyncEvents, onyxKey)) {\n                return;\n            }\n\n            Storage.getItem(onyxKey)\n                .then(value => onStorageKeyChanged(onyxKey, value));\n        });\n    },\n};\n\nexport default webStorage;\n","import {Platform} from 'react-native';\n\nconst Storage = Platform.select({\n    default: () => require('./WebStorage').default,\n    native: () => require('./NativeStorage').default,\n})();\n\nexport default Storage;\n","/**\n * The AsyncStorage provider stores everything in a key/value store by\n * converting the value to a JSON string\n */\n\nimport _ from 'underscore';\nimport AsyncStorage from '@react-native-async-storage/async-storage';\n\nconst provider = {\n    /**\n     * Get the value of a given key or return `null` if it's not available in storage\n     * @param {String} key\n     * @return {Promise<*>}\n     */\n    getItem(key) {\n        return AsyncStorage.getItem(key)\n            .then((value) => {\n                const parsed = value && JSON.parse(value);\n                return parsed;\n            });\n    },\n\n    /**\n     * Get multiple key-value pairs for the give array of keys in a batch\n     * @param {String[]} keys\n     * @return {Promise<Array<[key, value]>>}\n     */\n    multiGet(keys) {\n        return AsyncStorage.multiGet(keys)\n            .then(pairs => _.map(pairs, ([key, value]) => [key, value && JSON.parse(value)]));\n    },\n\n    /**\n     * Sets the value for a given key. The only requirement is that the value should be serializable to JSON string\n     * @param {String} key\n     * @param {*} value\n     * @return {Promise<void>}\n     */\n    setItem(key, value) {\n        return AsyncStorage.setItem(key, JSON.stringify(value));\n    },\n\n    /**\n     * Stores multiple key-value pairs in a batch\n     * @param {Array<[key, value]>} pairs\n     * @return {Promise<void>}\n     */\n    multiSet(pairs) {\n        const stringPairs = _.map(pairs, ([key, value]) => [key, JSON.stringify(value)]);\n        return AsyncStorage.multiSet(stringPairs);\n    },\n\n    /**\n     * Multiple merging of existing and new values in a batch\n     * @param {Array<[key, value]>} pairs\n     * @return {Promise<void>}\n     */\n    multiMerge(pairs) {\n        const stringPairs = _.map(pairs, ([key, value]) => [key, JSON.stringify(value)]);\n        return AsyncStorage.multiMerge(stringPairs);\n    },\n\n    /**\n     * Returns all keys available in storage\n     * @returns {Promise<String[]>}\n     */\n    getAllKeys: AsyncStorage.getAllKeys,\n\n    /**\n     * Remove given key and it's value from storage\n     * @param {String} key\n     * @returns {Promise<void>}\n     */\n    removeItem: AsyncStorage.removeItem,\n\n    /**\n     * Clear absolutely everything from storage\n     * @returns {Promise<void>}\n     */\n    clear: AsyncStorage.clear,\n};\n\nexport default provider;\n","/**\n * @file\n * The storage provider based on localforage allows us to store most anything in its\n * natural form in the underlying DB without having to stringify or de-stringify it\n */\n\nimport localforage from 'localforage';\nimport _ from 'underscore';\nimport lodashMerge from 'lodash/merge';\nimport SyncQueue from '../../SyncQueue';\n\nlocalforage.config({\n    name: 'OnyxDB'\n});\n\nconst provider = {\n    /**\n     * Writing very quickly to IndexedDB causes performance issues and can lock up the page and lead to jank.\n     * So, we are slowing this process down by waiting until one write is complete before moving on\n     * to the next.\n     */\n    setItemQueue: new SyncQueue(({key, value, shouldMerge}) => {\n        if (shouldMerge) {\n            return localforage.getItem(key)\n                .then((existingValue) => {\n                    const newValue = _.isObject(existingValue)\n                        ? lodashMerge({}, existingValue, value)\n                        : value;\n                    return localforage.setItem(key, newValue);\n                });\n        }\n\n        return localforage.setItem(key, value);\n    }),\n\n    /**\n     * Get multiple key-value pairs for the give array of keys in a batch\n     * @param {String[]} keys\n     * @return {Promise<Array<[key, value]>>}\n     */\n    multiGet(keys) {\n        const pairs = _.map(\n            keys,\n            key => localforage.getItem(key)\n                .then(value => [key, value])\n        );\n\n        return Promise.all(pairs);\n    },\n\n    /**\n     * Multiple merging of existing and new values in a batch\n     * @param {Array<[key, value]>} pairs\n     * @return {Promise<void>}\n     */\n    multiMerge(pairs) {\n        const tasks = _.map(pairs, ([key, value]) => this.setItemQueue.push({key, value, shouldMerge: true}));\n\n        // We're returning Promise.resolve, otherwise the array of task results will be returned to the caller\n        return Promise.all(tasks).then(() => Promise.resolve());\n    },\n\n    /**\n     * Stores multiple key-value pairs in a batch\n     * @param {Array<[key, value]>} pairs\n     * @return {Promise<void>}\n     */\n    multiSet(pairs) {\n        // We're returning Promise.resolve, otherwise the array of task results will be returned to the caller\n        const tasks = _.map(pairs, ([key, value]) => this.setItem(key, value));\n        return Promise.all(tasks).then(() => Promise.resolve());\n    },\n\n    /**\n     * Clear absolutely everything from storage\n     * @returns {Promise<void>}\n     */\n    clear: localforage.clear,\n\n    /**\n     * Returns all keys available in storage\n     * @returns {Promise<String[]>}\n     */\n    getAllKeys: localforage.keys,\n\n    /**\n     * Get the value of a given key or return `null` if it's not available in storage\n     * @param {String} key\n     * @return {Promise<*>}\n     */\n    getItem: localforage.getItem,\n\n    /**\n     * Remove given key and it's value from storage\n     * @param {String} key\n     * @returns {Promise<void>}\n     */\n    removeItem: localforage.removeItem,\n\n    /**\n     * Sets the value for a given key. The only requirement is that the value should be serializable to JSON string\n     * @param {String} key\n     * @param {*} value\n     * @return {Promise<void>}\n     */\n    setItem(key, value) {\n        return this.setItemQueue.push({key, value});\n    },\n};\n\nexport default provider;\n","/**\n * This is a higher order component that provides the ability to map a state property directly to\n * something in Onyx (a key/value store). That way, as soon as data in Onyx changes, the state will be set and the view\n * will automatically change to reflect the new data.\n */\nimport React from 'react';\nimport _ from 'underscore';\nimport PropTypes from 'prop-types';\nimport Str from 'expensify-common/lib/str';\nimport Onyx from './Onyx';\n\n/**\n * Returns the display name of a component\n *\n * @param {object} component\n * @returns {string}\n */\nfunction getDisplayName(component) {\n    return component.displayName || component.name || 'Component';\n}\n\nexport default function (mapOnyxToState) {\n    // A list of keys that must be present in tempState before we can render the WrappedComponent\n    const requiredKeysForInit = _.chain(mapOnyxToState)\n        .omit(config => config.initWithStoredValues === false)\n        .keys()\n        .value();\n\n    return (WrappedComponent) => {\n        class withOnyx extends React.Component {\n            constructor(props) {\n                super(props);\n\n                this.setWithOnyxState = this.setWithOnyxState.bind(this);\n\n                // This stores all the Onyx connection IDs to be used when the component unmounts so everything can be\n                // disconnected. It is a key value store with the format {[mapping.key]: connectionID}.\n                this.activeConnectionIDs = {};\n\n                // Object holding the temporary initial state for the component while we load the various Onyx keys\n                this.tempState = {};\n\n                this.state = {\n                    // If there are no required keys for init then we can render the wrapped component immediately\n                    loading: requiredKeysForInit.length > 0,\n                };\n            }\n\n            componentDidMount() {\n                // Subscribe each of the state properties to the proper Onyx key\n                _.each(mapOnyxToState, (mapping, propertyName) => {\n                    this.connectMappingToOnyx(mapping, propertyName);\n                });\n                this.checkEvictableKeys();\n            }\n\n            componentDidUpdate(prevProps) {\n                // If any of the mappings use data from the props, then when the props change, all the\n                // connections need to be reconnected with the new props\n                _.each(mapOnyxToState, (mapping, propertyName) => {\n                    const previousKey = Str.result(mapping.key, prevProps);\n                    const newKey = Str.result(mapping.key, this.props);\n\n                    if (previousKey !== newKey) {\n                        Onyx.disconnect(this.activeConnectionIDs[previousKey], previousKey);\n                        delete this.activeConnectionIDs[previousKey];\n                        this.connectMappingToOnyx(mapping, propertyName);\n                    }\n                });\n                this.checkEvictableKeys();\n            }\n\n            componentWillUnmount() {\n                // Disconnect everything from Onyx\n                _.each(mapOnyxToState, (mapping) => {\n                    const key = Str.result(mapping.key, this.props);\n                    const connectionID = this.activeConnectionIDs[key];\n                    Onyx.disconnect(connectionID, key);\n                });\n            }\n\n            /**\n             * This method is used externally by sendDataToConnection to prevent unnecessary renders while a component\n             * still in a loading state. The temporary initial state is saved to the component instance and setState()\n             * only called once all the necessary data has been collected.\n             *\n             * @param {String} statePropertyName\n             * @param {*} val\n             */\n            setWithOnyxState(statePropertyName, val) {\n                if (!this.state.loading) {\n                    this.setState({[statePropertyName]: val});\n                    return;\n                }\n\n                this.tempState[statePropertyName] = val;\n\n                // All state keys should exist and at least have a value of null\n                if (_.some(requiredKeysForInit, key => _.isUndefined(this.tempState[key]))) {\n                    return;\n                }\n\n                this.setState({...this.tempState, loading: false});\n                delete this.tempState;\n            }\n\n            /**\n             * Makes sure each Onyx key we requested has been set to state with a value of some kind.\n             * We are doing this so that the wrapped component will only render when all the data\n             * it needs is available to it.\n             */\n            checkEvictableKeys() {\n                // We will add this key to our list of recently accessed keys\n                // if the canEvict function returns true. This is necessary criteria\n                // we MUST use to specify if a key can be removed or not.\n                _.each(mapOnyxToState, (mapping) => {\n                    if (_.isUndefined(mapping.canEvict)) {\n                        return;\n                    }\n\n                    const canEvict = Str.result(mapping.canEvict, this.props);\n                    const key = Str.result(mapping.key, this.props);\n\n                    if (!Onyx.isSafeEvictionKey(key)) {\n                        // eslint-disable-next-line max-len\n                        throw new Error(`canEvict cannot be used on key '${key}'. This key must explicitly be flagged as safe for removal by adding it to Onyx.init({safeEvictionKeys: []}).`);\n                    }\n\n                    if (canEvict) {\n                        Onyx.removeFromEvictionBlockList(key, mapping.connectionID);\n                    } else {\n                        Onyx.addToEvictionBlockList(key, mapping.connectionID);\n                    }\n                });\n            }\n\n            /**\n             * Takes a single mapping and binds the state of the component to the store\n             *\n             * @param {object} mapping\n             * @param {string|function} mapping.key key to connect to. can be a string or a\n             * function that takes this.props as an argument and returns a string\n             * @param {string} statePropertyName the name of the state property that Onyx will add the data to\n             * @param {boolean} [mapping.initWithStoredValues] If set to false, then no data will be prefilled into the\n             *  component\n             */\n            connectMappingToOnyx(mapping, statePropertyName) {\n                const key = Str.result(mapping.key, this.props);\n\n                this.activeConnectionIDs[key] = Onyx.connect({\n                    ...mapping,\n                    key,\n                    statePropertyName,\n                    withOnyxInstance: this,\n                });\n            }\n\n            render() {\n                if (this.state.loading) {\n                    return null;\n                }\n\n                // Remove any internal state properties used by withOnyx\n                // that should not be passed to a wrapped component\n                let stateToPass = _.omit(this.state, 'loading');\n                stateToPass = _.omit(stateToPass, value => _.isNull(value));\n\n                // Remove any null values so that React replaces them with default props\n                const propsToPass = _.omit(this.props, value => _.isNull(value));\n\n                // Spreading props and state is necessary in an HOC where the data cannot be predicted\n                return (\n                    <WrappedComponent\n                        // eslint-disable-next-line react/jsx-props-no-spreading\n                        {...propsToPass}\n                        // eslint-disable-next-line react/jsx-props-no-spreading\n                        {...stateToPass}\n                        ref={this.props.forwardedRef}\n                    />\n                );\n            }\n        }\n\n        withOnyx.propTypes = {\n            forwardedRef: PropTypes.oneOfType([\n                PropTypes.func,\n                PropTypes.shape({current: PropTypes.instanceOf(React.Component)}),\n            ]),\n        };\n        withOnyx.defaultProps = {\n            forwardedRef: undefined,\n        };\n        withOnyx.displayName = `withOnyx(${getDisplayName(WrappedComponent)})`;\n        return React.forwardRef((props, ref) => {\n            const Component = withOnyx;\n            // eslint-disable-next-line react/jsx-props-no-spreading\n            return <Component {...props} forwardedRef={ref} />;\n        });\n    };\n}\n","/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nvar ReactPropTypesSecret = require('./lib/ReactPropTypesSecret');\n\nfunction emptyFunction() {}\nfunction emptyFunctionWithReset() {}\nemptyFunctionWithReset.resetWarningCache = emptyFunction;\n\nmodule.exports = function() {\n  function shim(props, propName, componentName, location, propFullName, secret) {\n    if (secret === ReactPropTypesSecret) {\n      // It is still safe when called from React.\n      return;\n    }\n    var err = new Error(\n      'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +\n      'Use PropTypes.checkPropTypes() to call them. ' +\n      'Read more at http://fb.me/use-check-prop-types'\n    );\n    err.name = 'Invariant Violation';\n    throw err;\n  };\n  shim.isRequired = shim;\n  function getShim() {\n    return shim;\n  };\n  // Important!\n  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.\n  var ReactPropTypes = {\n    array: shim,\n    bool: shim,\n    func: shim,\n    number: shim,\n    object: shim,\n    string: shim,\n    symbol: shim,\n\n    any: shim,\n    arrayOf: getShim,\n    element: shim,\n    elementType: shim,\n    instanceOf: getShim,\n    node: shim,\n    objectOf: getShim,\n    oneOf: getShim,\n    oneOfType: getShim,\n    shape: getShim,\n    exact: getShim,\n\n    checkPropTypes: emptyFunctionWithReset,\n    resetWarningCache: emptyFunction\n  };\n\n  ReactPropTypes.PropTypes = ReactPropTypes;\n\n  return ReactPropTypes;\n};\n","/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nif (process.env.NODE_ENV !== 'production') {\n  var ReactIs = require('react-is');\n\n  // By explicitly using `prop-types` you are opting into new development behavior.\n  // http://fb.me/prop-types-in-prod\n  var throwOnDirectAccess = true;\n  module.exports = require('./factoryWithTypeCheckers')(ReactIs.isElement, throwOnDirectAccess);\n} else {\n  // By explicitly using `prop-types` you are opting into new production behavior.\n  // http://fb.me/prop-types-in-prod\n  module.exports = require('./factoryWithThrowingShims')();\n}\n","/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nvar ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';\n\nmodule.exports = ReactPropTypesSecret;\n","module.exports = __WEBPACK_EXTERNAL_MODULE__6878__;","module.exports = __WEBPACK_EXTERNAL_MODULE__3246__;","module.exports = __WEBPACK_EXTERNAL_MODULE__6097__;","module.exports = __WEBPACK_EXTERNAL_MODULE__3349__;","module.exports = __WEBPACK_EXTERNAL_MODULE__9179__;","module.exports = __WEBPACK_EXTERNAL_MODULE__8156__;","module.exports = __WEBPACK_EXTERNAL_MODULE__9925__;","module.exports = __WEBPACK_EXTERNAL_MODULE__3136__;","module.exports = __WEBPACK_EXTERNAL_MODULE__4952__;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","import Onyx from './lib/Onyx';\nimport withOnyx from './lib/withOnyx';\n\nexport default Onyx;\nexport {withOnyx};\n"],"names":["root","factory","exports","module","require","define","amd","self","__WEBPACK_EXTERNAL_MODULE__4952__","__WEBPACK_EXTERNAL_MODULE__6097__","__WEBPACK_EXTERNAL_MODULE__9179__","__WEBPACK_EXTERNAL_MODULE__9925__","__WEBPACK_EXTERNAL_MODULE__3349__","__WEBPACK_EXTERNAL_MODULE__6878__","__WEBPACK_EXTERNAL_MODULE__3136__","__WEBPACK_EXTERNAL_MODULE__3246__","__WEBPACK_EXTERNAL_MODULE__8156__","arr","len","length","i","arr2","Array","isArray","arrayLikeToArray","ReferenceError","instance","Constructor","TypeError","_defineProperties","target","props","descriptor","enumerable","configurable","writable","Object","defineProperty","key","protoProps","staticProps","prototype","obj","value","_extends","assign","arguments","source","hasOwnProperty","call","apply","this","superPropBase","_get","property","receiver","Reflect","get","base","desc","getOwnPropertyDescriptor","_getPrototypeOf","o","setPrototypeOf","getPrototypeOf","__proto__","subClass","superClass","create","constructor","__esModule","iter","Symbol","iterator","from","_arr","_n","_d","_e","undefined","_s","_i","next","done","push","err","objectWithoutPropertiesLoose","excluded","getOwnPropertySymbols","sourceSymbolKeys","indexOf","propertyIsEnumerable","sourceKeys","keys","_typeof","assertThisInitialized","_setPrototypeOf","p","arrayWithHoles","iterableToArrayLimit","unsupportedIterableToArray","nonIterableRest","object","arrayWithoutHoles","iterableToArray","nonIterableSpread","minLen","n","toString","slice","name","test","callback","logger","message","level","MDTable","getTitle","getHeading","getRows","join","JSON","stringify","idx","replace","leftAlignedCols","includes","split","AsciTable","title","heading","rows","table","forEach","setAlign","RIGHT","LEFT","lastConnectionID","callbackToStateMapping","onyxKeys","recentlyAccessedKeys","evictionAllowList","evictionBlocklist","defaultKeyStates","deferredInitTask","cache","hasCacheForKey","Promise","resolve","getValue","taskName","hasPendingTask","getTaskPromise","promise","Storage","getItem","then","val","set","catch","logInfo","captureTask","getAllKeys","storedKeys","_","each","addKey","isCollectionKey","contains","values","COLLECTION","isKeyMatch","configKey","Str","startsWith","isSafeEvictionKey","testKey","some","removeLastAccessedKey","without","addLastAccessedKey","removeFromEvictionBlockList","connectionID","addAllSafeEvictionKeysToRecentlyAccessedList","safeEvictionKey","keyChanged","data","isNull","subscriber","isFunction","withOnyxInstance","setState","prevState","collection","clone","statePropertyName","sendDataToConnection","config","setWithOnyxState","remove","removeItem","evictStorageAndRetry","error","onyxMethod","args","logAlert","keyForRemoval","find","isObject","Boolean","mergeQueue","hasPendingMergeForKey","setItem","prepareKeyValuePairsForStorage","map","multiSet","keyValuePairs","merge","modifiedData","mergeValues","every","reduce","mergeValue","newData","omit","finalObjectKey","last","applyMerge","initializeWithDefaultKeyStates","multiGet","pairs","asObject","merged","clear","mergeCollection","collectionKey","dataKey","Error","persistedKeys","chain","partition","existingKeys","newKeys","existingKeyCollection","pick","newCollection","keyValuePairsForExistingCollection","keyValuePairsForNewCollection","promises","multiMerge","all","isSubscribedToCollectionKey","isSubscribedToCollectionMemberKey","cachedCollection","collectionMemberKeys","filter","storedKey","prev","curr","cachedValue","getCachedCollection","finalCollection","dataFromCollection","isUndefined","keysChanged","Onyx","connect","mapping","initWithStoredValues","removeLeastRecentlyUsedKeys","canEvict","matchingKeys","finalObject","disconnect","keyToRemoveFromEvictionBlocklist","init","initialKeyStates","safeEvictionKeys","maxCachedKeysCount","captureMetrics","shouldSyncMultipleInstances","global","localStorage","keysToDisableSyncEvents","applyDecorators","setRecentKeysLimit","keepInstancesSync","registerLogger","addToEvictionBlockList","decorate","decorateWithMetrics","getMetrics","resetMetrics","printMetrics","isDefined","negate","OnyxCache","storageKeys","Set","recentKeys","storageMap","pendingPromises","bindAll","addToAccessedKeys","add","mergedKeys","finally","delete","size","maxRecentKeysSize","recentlyAccessed","keysToRemove","difference","drop","limit","SyncQueue","run","queue","isProcessing","shift","reject","process","deferred","res","func","alias","decoratedAliases","has","decorated","mark","addMark","originalPromise","result","measureMarkToNow","summaries","summary","calls","flatten","measure","performance","clearMarks","detail","clearMeasures","raw","format","methods","totalTime","lastCompleteCall","tableSummary","timeOrigin","methodNames","methodCallTables","methodName","avg","methodStats","addRow","toDuration","total","max","min","lastCall","startTime","duration","String","allTables","toLowerCase","toCSV","toJSON","lastComplete","mainOutput","console","info","groupCollapsed","groupEnd","startMark","start","end","now","sum","list","prop","memo","getEntriesByType","entry","groupBy","millis","minute","toFixed","second","SYNC_ONYX","raiseStorageSyncEvent","onyxKey","onStorageKeyChanged","tasks","addEventListener","event","newValue","webStorage","Platform","select","default","native","AsyncStorage","parse","stringPairs","provider","localforage","setItemQueue","shouldMerge","existingValue","mapOnyxToState","requiredKeysForInit","WrappedComponent","component","withOnyx","bind","activeConnectionIDs","tempState","state","loading","propertyName","connectMappingToOnyx","checkEvictableKeys","prevProps","previousKey","stateToPass","propsToPass","ref","forwardedRef","React","Component","propTypes","PropTypes","oneOfType","shape","current","instanceOf","defaultProps","displayName","forwardRef","ReactPropTypesSecret","emptyFunction","emptyFunctionWithReset","resetWarningCache","shim","propName","componentName","location","propFullName","secret","getShim","isRequired","ReactPropTypes","array","bool","number","string","symbol","any","arrayOf","element","elementType","node","objectOf","oneOf","exact","checkPropTypes","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","g","globalThis","Function","e","window"],"sourceRoot":""}